import pandas as pd, numpy as np, datetime as dt, os, ta, pytz, investpy, statistics as sts, MetaTrader5 as mt5, hashlib, math
from time import sleep
import tensorflow as tf
from datetime import datetime
from finta import TA
from keras import layers
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.optimizers import Adam
from keras.models import load_model
from keras.layers import LSTM, Dense, Dropout, Conv1D, GRU, LeakyReLU, Flatten, SimpleRNN, MaxPooling1D, TimeDistributed, Reshape, Conv2D, MaxPooling2D, Bidirectional
from tensorflow.python.client import device_lib
# from keras import mixed_precision

# Set GPU device
# physical_devices = tf.config.list_physical_devices('GPU')
# tf.config.experimental.set_memory_growth(physical_devices[0], True)

#*_________________________________________________________________________________________________________________________________________________
class DataFetcher:
    def __init__(self, folder_link):
        self.folder_link = folder_link

    def simple_csv_calling(self, symbol):
        data = pd.read_csv(self.folder_link + symbol + '.csv')
        return data

    def fetch_from_MT5_without_time_parsing_definite_period(self, st_year, st_month, st_day, e_year, e_month, e_day, symbol) :
        data = pd.DataFrame(mt5.copy_rates_range(symbol,
                                                 mt5.TIMEFRAME_M15,
                                                 datetime(st_year, st_month, st_day),
                                                 datetime(e_year, e_month, e_day)))
        data['currency_base'] = mt5.symbol_info(symbol)._asdict()['currency_base']
        data['currency_profit'] = mt5.symbol_info(symbol)._asdict()['currency_profit']
        csv_file = data.to_csv(self.folder_link + symbol + '.csv', index=False)
        return csv_file

    def fetch_from_MT5_without_time_parsing_changing_period_M15(self, D, symbol):
        data = pd.DataFrame(mt5.copy_rates_range(symbol,
                                                 mt5.TIMEFRAME_M15,
                                                 (datetime.now() - pd.DateOffset(days=D)),
                                                 datetime.now()))
        csv_file = data.to_csv(self.folder_link + symbol + '.csv', index=False)
        return csv_file

    def fetch_from_MT5_without_time_parsing_changing_period_H1(self, D, symbol):
        data = pd.DataFrame(mt5.copy_rates_range(symbol,
                                                 mt5.TIMEFRAME_H1,
                                                 (datetime.now() - pd.DateOffset(days=D)),
                                                 datetime.now()))
        csv_file = data.to_csv(self.folder_link + symbol + '.csv', index=False)
        return csv_file

    def fetch_from_MT5_with_time_parsing_definite_period(self, st_year, st_month, st_day, e_year, e_month, e_day, symbol):
        data = pd.DataFrame(mt5.copy_rates_range(symbol,
                                                 mt5.TIMEFRAME_M15,
                                                 datetime(st_year, st_month, st_day),
                                                 datetime(e_year, e_month, e_day)))
        data['DateandTime'] = pd.to_datetime(data['time'], unit='s')
        data['currency_base'] = mt5.symbol_info(symbol)._asdict()['currency_base']
        data['currency_profit'] = mt5.symbol_info(symbol)._asdict()['currency_profit']
        csv_file = data.to_csv(self.folder_link + symbol + '.csv', index=False)
        return csv_file

# data_fetcher = DataFetcher('path/to/folder/')
# data = data_fetcher.simple_csv_calling('stock_name')
# csv_file = data_fetcher.fetch_from_MT5_without_time_parsing_definite_period(st_year, st_month, st_day, e_year, e_month, e_day, 'symbol')
#*_________________________________________________________________________________________________________________________________________________
class MultiplesStrategiesSignal:

    def __init__(self, data):
        self.data = data
    
    def calculate_ema(self, window=50):
        self.data["EMA_"+str(window)] = ta.trend.EMAIndicator(close=self.data['close'], window=window).ema_indicator()

    def calculate_atr(self, window=14):
        self.data['ATR'] = ta.volatility.AverageTrueRange(high=self.data['high'], low=self.data['low'], close=self.data['close'], window=window).average_true_range()

    def calculate_shifted_columns(self, shift_periods):
        self.data['shift_'+str(shift_periods)] = self.data['close'].shift(shift_periods)

    def calculate_pivot_points(self):
        self.data['pivot']  = (self.data['open'] + self.data['high'] + self.data['low'] + self.data['close']) / 4
        self.data['r1'] = (2 * self.pivot) - self.data['low']
        self.data['s1'] = (2 * self.pivot) - self.data['high']
        self.data['r2'] = self.data['pivot'] + (self.data['high'] - self.data['low'])
        self.data['s2'] = self.data['pivot'] - (self.data['high'] - self.data['low'])
        self.data['r3'] = self.data['high'] + 2 * (self.data['pivot'] - self.data['low'])
        self.data['s3'] = self.data['low'] - 2 * (self.data['high'] - self.data['pivot'])

    def calculate_rsi(self, window=14):
        self.data['RSI'] = ta.momentum.RSIIndicator(close=self.data['close'], window=window).rsi()

    def generate_atr_signals(self):
        self.atr =ta.volatility.AverageTrueRange(high=self.data['high'], low=self.data['low'], close=self.data['close'], window=14).average_true_range()
        self.data['ATR_Signal'] = np.where(self.atr > self.atr.shift(1), 1, np.where(self.atr < self.atr.shift(1), -1, 0))

    def calculate_macd(self):
        macd                        = ta.trend.MACD(close=self.data['close'])
        self.data['MACD']           = macd.macd()
        self.data['Signal_Line']    = macd.macd_signal()
        self.data['MACD_Histogram'] = macd.macd_diff()

    def calculate_bollinger_bands(self, window=20, window_dev=2):
        indicator_bb = ta.volatility.BollingerBands(close=self.data['close'], window=window, window_dev=window_dev)
        self.data['upper_band'] = indicator_bb.bollinger_hband()
        self.data['lower_band'] = indicator_bb.bollinger_lband()

    def calculate_stochastic_oscillator(self):
        stochastic      = ta.momentum.StochasticOscillator(self.data['high'], self.data['low'], self.data['close'])
        self.data['%K'] = stochastic.stoch()
        self.data['%D'] = stochastic.stoch_signal()

    def calculate_ichimoku_cloud(self):
        ichimoku = ta.trend.IchimokuIndicator(high=self.data['high'], low=self.data['low'])
        self.data['Ichimoku_Cloud_Base'] = ichimoku.ichimoku_base_line()
        self.data['Ichimoku_Cloud_Conversion'] = ichimoku.ichimoku_conversion_line()
        self.data['Ichimoku_Cloud_Lagging_a'] = ichimoku.ichimoku_a()
        self.data['Ichimoku_Cloud_Leading_b'] = ichimoku.ichimoku_b()

    def calculate_parabolic_sar(self):
        self.data['Parabolic_SAR'] = ta.trend.PSARIndicator(close=self.data['close'], high=self.data['high'], low=self.data['low']).psar()

    def calculate_obv(self):
        self.data['OBV'] = ta.volume.OnBalanceVolumeIndicator(close=self.data['close'], volume=self.data['tick_volume'])

    def calculate_adx(self):
        indicator_adx = ta.trend.ADXIndicator(high=self.data['high'], low=self.data['low'], close=self.data['close'])
        self.data['ADX'] = indicator_adx.adx()
        self.data['+DI'] = indicator_adx.adx_pos()
        self.data['-DI'] = indicator_adx.adx_neg()

    def calculate_cci(self):
        self.data['CCI'] = ta.trend.CCIIndicator(high=self.data['high'], low=self.data['low'], close=self.data['close'])

    def calculate_williams_r(self):
        self.data['Williams_R'] = ta.momentum.WilliamsRIndicator(high=self.data['high'], low=self.data['low'], close=self.data['close'])

    def calculate_donchian_channels(self, window=20):
        self.data['Donchian_High'] = self.data['high'].rolling(window=window).max()
        self.data['Donchian_Low'] = self.data['low'].rolling(window=window).min()
        self.data['Donchian_Median'] = (self.data['Donchian_High'] + self.data['Donchian_Low']) / 2

    def calculate_fibonacci_retracement_levels(self):
        self.data['Fibonacci_0.382'] = self.data['high'].max() - 0.382 * (self.data['high'].max() - self.data['low'].min())
        self.data['Fibonacci_0.618'] = self.data['high'].max() - 0.618 * (self.data['high'].max() - self.data['low'].min())
        return self.data
    #?_______________________________________________________________________________________
    def market_opening_time(self):
        self.tm = TimeManager()
        self.data["datetime"]    = pd.to_datetime(self.data['time'], unit='s') if 'datetime' not in self.data else self.data["datetime"].astype('datetime64[ns]')
        self.data['hour']        = pd.to_datetime(self.data['datetime'], format='%H:%M:%S').dt.hour
        self.data['NYC']         = self.data.apply(lambda x: self.tm.diff_of_Market_from_given_hours(location_no=1, Given_Hour=x['hour']), axis=1)
        self.data['LON']         = self.data.apply(lambda x: self.tm.diff_of_Market_from_given_hours(location_no=2, Given_Hour=x['hour']), axis=1)
        self.data['SYD']         = self.data.apply(lambda x: self.tm.diff_of_Market_from_given_hours(location_no=3, Given_Hour=x['hour']), axis=1)
        self.data['TOK']         = self.data.apply(lambda x: self.tm.diff_of_Market_from_given_hours(location_no=4, Given_Hour=x['hour']), axis=1)
        self.data['NYC_Open']    = self.data.apply(lambda x: self.tm.market_open(location_no=1, Given_Hour=x['hour']), axis=1)
        self.data['LON_Open']    = self.data.apply(lambda x: self.tm.market_open(location_no=2, Given_Hour=x['hour']), axis=1)
        self.data['SYD_Open']    = self.data.apply(lambda x: self.tm.market_open(location_no=3, Given_Hour=x['hour']), axis=1)
        self.data['TOK_Open']    = self.data.apply(lambda x: self.tm.market_open(location_no=4, Given_Hour=x['hour']), axis=1)
        self.data.drop(['NYC', 'LON', 'SYD', 'TOK'], axis=1, inplace=True)
        return self.data
    #?_______________________________________________________________________________________
    def adding_15_indicators_in_dataframe(self):
        self.data['%-chg']       = self.data['close'].pct_change()
        self.data['Log returns'] = np.log(self.data['close']/self.data['close'].shift())
        self.data['SMA'+str(20)] = self.data['close'].rolling(20).mean()
        self.data['EMA'+str(20)] = self.data['close'].ewm(span=20, adjust=False).mean()
        self.data['ATR']         = ta.volatility.average_true_range(self.data['high'], self.data['low'], self.data['close'], n=14)
        self.data['MACD']        = self.data['close'].ewm(span=12, adjust=False).mean() - self.data['close'].ewm(span=26, adjust=False).mean()
        self.data['Signal line'] = self.data['MACD'].ewm(span=9, adjust=False).mean()
        self.data['%K']          = (self.data['close'] - self.data['low'].rolling(14).min())*100/(self.data['high'].rolling(14).max() - self.data['low'].rolling(14).min())
        self.data['%D']          = self.data['%K'].rolling(3).mean()
        self.data['Avg HL']      = (self.data['high'].rolling(50).max()-self.data['low'].rolling(50).min())    
        self.data['Cur_HL_D']    = (self.data['high'].shift()-self.data['low'].shift())
        self.data['std_20']      = self.data['close'].rolling(20).std()
        self.data['sma_20']      = self.data['close'].rolling(20).mean()
        self.data['upper_band_20'] = self.data['sma_20'] + 2 * self.data['std_20']
        self.data['lower_band_20'] = self.data['sma_20'] - 2 * self.data['std_20']    
        self.data.dropna

        return self.data

    def adding_previous_candle_data(self):
        self.data['P_open']          = self.data['open'].shift(1)
        self.data['P_high']          = self.data['high'].shift(1)
        self.data['P_low']           = self.data['low'].shift(1)
        self.data['P_close']         = self.data['close'].shift(1)
        self.data['P_spread']        = self.data['spread'].shift(1)
        self.data['P_tick_volume']   = self.data['tick_volume'].shift(1)
        self.data.dropna

        return self.data

    def adding_shift_change_in_dataFrame(self, Formula='shift_change', Required='close', shift_value=3):
        for i in range(1, shift_value + 1):

            if Formula in ['shift_change', 'shift']:
                self.data[Required+'_'+str(i)] = self.data[Required].shift(i)

            if Formula in ['shift_change', 'change']:
                self.data['chg_'+Required+'_'+str(i)] = ((self.data[Required].shift(i) - self.data[Required].shift(i+1)) / self.data[Required].shift(i+1)) * 100
        return self.data

    def adding_RSI_STOCH_SHIFT_ATR_TRIX(self, Required):
        self.data[Required+'-3'] = self.data[Required].shift(3)
        self.data[Required+'-2'] = self.data[Required].shift(2)
        self.data[Required+'-1'] = self.data[Required].shift(1)
        self.data['CHG']         = (self.data[Required] - self.data[Required].shift(1))
        self.data['EMA']        = self.TA.EMA(self.data)
        self.data['DEMA']       = self.TA.DEMA(self.data)
        self.data['TEMA']       = self.TA.TEMA(self.data)
        self.data['RSI']        = self.TA.RSI(self.data)
        self.data['IFT_RSI']    = self.TA.IFT_RSI(self.data)
        self.data['STOCH_K']    = self.TA.STOCH(self.data)
        self.data['STOCH_D']    = self.TA.STOCHD(self.data)
        self.data['TRIX']       = self.TA.TRIX(self.data)
        self.data['ATR']        = self.TA.ATR(self.data)
        self.data               = self.data.dropna()
        return self.data

    def adding_RSI_Stoch_shift_Market(self, data_eco, Required):
        self.data[Required+'-3'] = self.data[Required].shift(3)
        self.data[Required+'-2'] = self.data[Required].shift(2)
        self.data[Required+'-1'] = self.data[Required].shift(1)
        self.data['RSI']        = self.TA.RSI(self.data)
        self.data['STOCH_K']    = self.TA.STOCH(self.data)
        self.data['STOCH_D']    = self.TA.STOCHD(self.data)
        self.data['ATR']        = self.TA.ATR(self.data)
        self.data               = self.Market_Opening_Time(data=data_eco)        
        self.data        = self.data.dropna()
        return self.data

    def adding_RSI_Stoch_shift(self, Required):
        self.data[Required+'-3']    = self.data[Required].shift(3)
        self.data[Required+'-2']    = self.data[Required].shift(2)
        self.data[Required+'-1']    = self.data[Required].shift(1)
        self.data['RSI']        = self.TA.RSI(self.data)
        self.data['STOCH_K']    = self.TA.STOCH(self.data)
        self.data['STOCH_D']    = self.TA.STOCHD(self.data)
        self.data['ATR']        = self.TA.ATR(self.data)
        self.data        = self.data.dropna()
        return self.data

    def adding_3_change_Shift_EC_Market(self, Required, Days_Back=30):
        self.data['time']        = self.data['time'].shift(3)
        self.data[Required+'-1'] = self.data[Required].shift(1)
        self.data[Required+'-2'] = self.data[Required].shift(2)
        self.data[Required+'-3'] = self.data[Required].shift(3)
        self.data[Required+'-Chg-1'] = ((self.data[Required].shift(1) - self.data[Required].shift(2)) / self.data[Required].shift(2)) * 100
        self.data[Required+'-Chg-2'] = ((self.data[Required].shift(2) - self.data[Required].shift(3)) / self.data[Required].shift(3)) * 100
        self.data[Required+'-Chg-3'] = ((self.data[Required].shift(3) - self.data[Required].shift(4)) / self.data[Required].shift(4)) * 100
        self.data['datetime'] = pd.to_datetime(self.data['time'], unit='s')
        ec = self.Ecomonical_Cleaned_Data(Days_Back, Ret_Pattern='For_Model')  #* Make sure to adjust the method call based on your class implementation.
        self.data = pd.merge(left=self.data, right=ec, how='left', left_on='datetime', right_on='datetime')
        self.data = self.Market_Opening_Time(self.data)

        self.data.sort_values(by='datetime', inplace=True)
        self.data.fillna(0, inplace=True)  #* Added inplace=True to fillna()
        
        return self.data

    def adding_3_change_3_Shift(self, Required):
        self.data['time'] = self.data['time'].shift(3)
        self.data[Required+'-3'] = self.data[Required].shift(3)
        self.data[Required+'-Chg-3'] = ((self.data[Required].shift(3) - self.data[Required].shift(4)) / self.data[Required].shift(4)) * 100
        self.data[Required+'-2'] = self.data[Required].shift(2)
        self.data[Required+'-Chg-2'] = ((self.data[Required].shift(2) - self.data[Required].shift(3)) / self.data[Required].shift(3)) * 100
        self.data[Required+'-1'] = self.data[Required].shift(1)
        self.data[Required+'-Chg-1'] = ((self.data[Required].shift(1) - self.data[Required].shift(2)) / self.data[Required].shift(2)) * 100    
        return self.data

    def adding_3_Shift_for_nth(self, Required, nth):
        self.data[Required+'-'+str(nth+3)] = self.data[Required].shift(nth+3)
        self.data[Required+'-'+str(nth+2)] = self.data[Required].shift(nth+2)
        self.data[Required+'-'+str(nth+1)] = self.data[Required].shift(nth+1)
        return self.data

    def adding_data_For_Prediction_of_Whole_Candle(self, Required='Whole_Candle', Days_Back=10):
        df = self.data
        df_X = self.adding_shift_change_in_dataFrame(df, 'high', shift_value=3, Formula='shift')
        df_X = self.adding_shift_change_in_dataFrame(df_X, 'high', shift_value=3, Formula='change')
        df_X = self.adding_shift_change_in_dataFrame(df_X, 'low', shift_value=3, Formula='shift')
        df_X = self.adding_shift_change_in_dataFrame(df_X, 'low', shift_value=3, Formula='change')
        df_X = self.adding_shift_change_in_dataFrame(df_X, 'close', shift_value=3, Formula='shift')
        df_X = self.adding_shift_change_in_dataFrame(df_X, 'close', shift_value=3, Formula='change')
        self.Market_Opening_Time(df_X)
        ec = pd.read_csv('./Eco_Cal/EC_7_Sorted_by_Date.csv')
        ec['datetime'] = pd.to_datetime(ec['datetime'], format='%Y-%m-%d %H:%M:%S')
        re = pd.merge(left=df_X, right=ec, how='left', left_on='datetime', right_on='datetime')
        re = re.fillna(0)
        re.sort_values(by='datetime', inplace=True)
        re_X = re.drop(columns=['open', 'high', 'low', 'close'], axis=1)
        re_Y = pd.DataFrame()
        re_Y['open'], re_Y['high'], re_Y['low'], re_Y['close'] = re['open'], re['high'], re['low'], re['close']
        return re_X, re_Y

    def adding_Shift_Change_Market_Time(self, Required, folder_eco, shift_value):
        df_X, df_Y = self.adding_shift_change_in_dataFrame(self.data, Required, shift_value, Formula='shift')
        df_X = self.Market_Opening_Time(data=df_X)
        df_X = df_X.drop(['datetime', 'hour'], axis=1)
        return df_X, df_Y

    def adding_Shift_Market_Time_Eco_Calander(self, Required, folder_eco, shift_value):
        df_X, df_Y = self.adding_shift_change_in_dataFrame(self.data, Required, shift_value, Formula='shift')
        df_X = self.Market_Opening_Time(data=df_X)
        ec = pd.read_csv(folder_eco + 'EC_7_Sorted_by_Date.csv')
        re = pd.merge(left=df_X, right=ec, how='left', left_on='datetime', right_on='datetime')
        re = re.fillna(0)
        re.sort_values(by='datetime', inplace=True)
        re = re.drop('datetime', axis=1)
        return re, df_Y

    def adding_Shift_Change_Market_Time_Eco_Calander_In_DataFrame(self, Required, folder_eco, shift_value):
        df_X, df_Y = self.adding_shift_change_in_dataFrame(self.data, Required, shift_value, Formula='shift_change')
        df_X = self.Market_Opening_Time(data=df_X)
        ec = pd.read_csv(folder_eco + 'EC_7_Sorted_by_Date.csv')
        ec['datetime'] = pd.to_datetime(ec['datetime'], format='%Y-%m-%d %H:%M:%S')
        re = pd.merge(left=df_X, right=ec, how='left', left_on='datetime', right_on='datetime')
        re = re.fillna(0)
        re.sort_values(by='datetime', inplace=True)
        re = re.drop('datetime', axis=1)
        return re, df_Y
    #?_______________________________________________________________________________________
    def generate_pivot_signals(self):
        self.pivot  = (self.data['open'] + self.data['high'] + self.data['low'] + self.data['close']) / 4
        self.r1     = (2 * self.pivot) - self.data['low']
        self.s1     = (2 * self.pivot) - self.data['high']
        self.data['Pivot_Signal'] = np.where(self.data['close'] > self.r1, 1, np.where(self.data['close'] < self.s1, -1, 0))
        return self.data

    def generate_ema50_200_crossover_signals(self):
        self.shift50            = ta.trend.EMAIndicator(close=self.data['close'], window=50).ema_indicator()
        self.shift200           = ta.trend.EMAIndicator(close=self.data['close'], window=200).ema_indicator()
        self.data['EMA50_100_Signal'] = np.where((self.shift200 < self.shift50), 1, np.where((self.shift200 > self.shift50), -1, 0))
        return self.data

    def generate_ma30_100_crossover_signals(self):
        self.shift30        = self.data['close'].shift(30)
        self.shift100       = self.data['close'].shift(100)
        self.data['MA30_100_Signal'] = np.where((self.shift100 < self.shift30), 1, np.where((self.shift100 > self.shift30), -1, 0))
        return self.data

    def generate_rsi_signals(self):
        self.rsi = ta.momentum.RSIIndicator(close=self.data['close'], window=14).rsi()
        self.data['RSI_Signal'] = np.where(self.rsi > 70, 1, np.where(self.rsi < 30, -1, 0))
        return self.data

    def generate_ema_rsi_atr_signals(self):
        self.rsi = ta.momentum.RSIIndicator(close=self.data['close'], window=14).rsi()
        self.ema50  = ta.trend.EMAIndicator(close=self.data['close'], window=50).ema_indicator()
        self.atr =ta.volatility.AverageTrueRange(high=self.data['high'], low=self.data['low'], close=self.data['close'], window=14).average_true_range()
        # self.data['EMA_RSI_ATR_Signal'] = np.where((self.rsi < 30) & (self.data['close'] > self.ema50 + (2 * self.atr)), 1, np.where((self.rsi > 70) & (self.data['close'] < self.ema50 - (2 * self.atr)), -1, 0))
        self.data['EMA_RSI_ATR_Signal'] = np.where((self.rsi > 30) & (self.data['close'] > self.ema50 + (2 * self.atr)), 1, np.where((self.rsi < 70) & (self.data['close'] < self.ema50 - (2 * self.atr)), -1, 0))
        return self.data

    def generate_macd_rsi_bb_signal(self):
        self.macd_line = ta.trend.MACD(close=self.data['close'], window_slow=26, window_fast=12).macd()
        self.signal_line = ta.trend.MACD(close=self.data['close'], window_slow=26, window_fast=12).macd_signal()
        self.upper_band = ta.volatility.BollingerBands(close=self.data['close'], window=20, window_dev=2).bollinger_hband()
        self.lower_band = ta.volatility.BollingerBands(close=self.data['close'], window=20, window_dev=2).bollinger_lband()
        self.rsi = ta.momentum.RSIIndicator(close=self.data['close'], window=14).rsi()
        self.data['MACD_RSI_BB_Signal'] = np.where((self.macd_line < self.signal_line) & (self.data['close'] < self.lower_band) & (self.rsi < 30), 1,
                                            np.where((self.macd_line > self.signal_line) & (self.data['close'] > self.upper_band) & (self.rsi > 70),-1,0))
        return self.data

    def generate_macd_rsi_signal(self):
        self.macd_line = ta.trend.MACD(close=self.data['close'], window_slow=26, window_fast=12).macd()
        self.signal_line = ta.trend.MACD(close=self.data['close'], window_slow=26, window_fast=12).macd_signal()
        self.rsi = ta.momentum.RSIIndicator(close=self.data['close'], window=14).rsi()
        self.data['MACD_RSI_Signal'] = np.where((self.macd_line < 0) & (self.rsi < 30), 1,
                                            np.where((self.macd_line > 0) & (self.rsi > 70),-1, 0))
        return self.data

    def generate_adx_vwap_ma50_signal(self):
        adx = ta.trend.ADXIndicator(high=self.data['high'], low=self.data['low'], close=self.data['close']).adx()
        sma50 = ta.trend.sma_indicator(close=self.data['close'], window=50)
        vwap = ta.volume.VolumeWeightedAveragePrice(high=self.data['high'], low=self.data['low'], close=self.data['close'], volume=self.data['tick_volume']).volume_weighted_average_price()

        self.data['ADX_VWAP_MA50_Signal'] = np.where((adx > 25) & (self.data['close'] < sma50) & (self.data['close'] < vwap),1,
                                               np.where((adx > 25) & (self.data['close'] > sma50) & (self.data['close'] > vwap),-1, 0))
        return self.data

    def generate_gann_signal(self):
        angles = [45, 26.565, 18.435, 14.036, 11.31]
        swing_points = []
        for i in range(1, len(self.data['close']) - 1):
            if (self.data['close'][i] > self.data['close'][i-1] and self.data['close'][i] > self.data['close'][i+1]) or \
                    (self.data['close'][i] < self.data['close'][i-1] and self.data['close'][i] < self.data['close'][i+1]):
                swing_points.append(self.data['close'][i])
        fan_lines = []
        for angle in angles:
            fan_line = [swing_point * np.cos(np.radians(angle)) for swing_point in swing_points]
            fan_lines.append(fan_line)
        signals = []
        for i in range(len(self.data['close'])):
            current_price = self.data['close'][i]
            signal = 0  # Default to no signal
            for j, fan_line in enumerate(fan_lines):
                if i > 0 and i < len(fan_line) - 1:
                    if current_price > fan_line[i] and current_price <= fan_line[i+1]:
                        signal = 1  # Up signal for crossing above fan line
                        break
                    elif current_price < fan_line[i] and current_price >= fan_line[i+1]:
                        signal = -1  # Down signal for crossing below fan line
                        break
            signals.append(signal)
        signals = np.array(signals)
        signals = np.where(signals > 0, 1, np.where(signals < 0, -1, 0))
        self.data['Gann_Signal'] = signals
        return self.data

    def generate_rsi_divergence_signals(self):
        self.rsi = ta.momentum.RSIIndicator(close=self.data['close'], window=14).rsi()
        self.data['RSI_divergence_signal'] = np.where((self.rsi.shift() < self.rsi) & (self.data['close'].shift() > self.data['close']), 1,
                                                    np.where((self.rsi.shift() > self.rsi) & (self.data['close'].shift() < self.data['close']), -1, 0))
        return self.data

    def generate_macd_signals(self):
        macd                        = ta.trend.MACD(close=self.data['close'])
        self.macd                   = macd.macd()
        self.macd_signal_line       = macd.macd_signal()
        self.macd_histogram         = macd.macd_diff()
        self.data['MACD_signal'] = np.where((self.macd > self.macd_signal_line) & (self.macd.shift() < self.macd_signal_line.shift()), 1,
                                            np.where((self.macd < self.macd_signal_line) & (self.macd.shift() > self.macd_signal_line.shift()), -1, 0))

    def generate_macd_histogram_signals(self):
        macd                        = ta.trend.MACD(close=self.data['close'])
        self.macd_histogram         = macd.macd_diff()
        self.data['MACD_histogram_signal'] = np.where(self.macd_histogram > 0, 1, np.where(self.macd_histogram < 0, -1, 0))
        return self.data

    def generate_bollinger_bands_signals(self, window=20, window_dev=2):
        indicator_bb = ta.volatility.BollingerBands(close=self.data['close'], window=window, window_dev=window_dev)
        self.upper_band = indicator_bb.bollinger_hband()
        self.lower_band = indicator_bb.bollinger_lband()
        self.data['BB_Signal'] = np.where(self.data['close'] > self.upper_band, 1, np.where(self.data['close'] < self.lower_band, -1, 0))
        return self.data

    def generate_stochastic_signals(self):
        stochastic      = ta.momentum.StochasticOscillator(self.data['high'], self.data['low'], self.data['close'])
        self.k = stochastic.stoch()
        self.d = stochastic.stoch_signal()
        self.data['Stochastic_Signal'] = np.where((self.k > self.d) & (self.k.shift() < self.d.shift()), 1,
                                            np.where((self.k < self.d) & (self.k.shift() > self.d.shift()), -1, 0))
        return self.data

    def generate_fibonacci_retracement_signals(self):
        self.Fibonacci_382 = self.data['high'].max() - 0.382 * (self.data['high'].max() - self.data['low'].min())
        self.Fibonacci_618 = self.data['high'].max() - 0.618 * (self.data['high'].max() - self.data['low'].min())
        self.data['Fibonacci_Signal'] = np.where(self.data['close'] > self.Fibonacci_618, 1,
                                                np.where(self.data['close'] < self.Fibonacci_382, -1, 0))
        return self.data

    def generate_ichimoku_cloud_signals(self):
        ichimoku = ta.trend.IchimokuIndicator(high=self.data['high'], low=self.data['low'])
        self.Ichimoku_Cloud_Base = ichimoku.ichimoku_base_line()
        self.data['Ichimoku_Signal'] = np.where(self.data['close'] > self.Ichimoku_Cloud_Base, 1,
                                                np.where(self.data['close'] < self.Ichimoku_Cloud_Base, -1, 0))
        return self.data

    def generate_parabolic_sar_signals(self):
        self.Parabolic_SAR= ta.trend.PSARIndicator(close=self.data['close'], high=self.data['high'], low=self.data['low']).psar()
        self.data['Parabolic_SAR_Signal'] = np.where(self.data['close'] > self.Parabolic_SAR, 1, np.where(self.data['close'] < self.Parabolic_SAR, -1, 0))
        return self.data

    def generate_obv_signals(self):
        self.obv = ta.volume.OnBalanceVolumeIndicator(close=self.data['close'], volume=self.data['tick_volume']).on_balance_volume()
        obv_series = pd.Series(self.obv, index=self.data.index)  # Convert obv to a Series
        self.data['OBV_Signal'] = np.where(obv_series > obv_series.shift(1), 1, np.where(obv_series < obv_series.shift(1), -1, 0))
        return self.data

    def generate_adx_signals(self):
        indicator_adx = ta.trend.ADXIndicator(high=self.data['high'], low=self.data['low'], close=self.data['close'])
        self.ADX = indicator_adx.adx()
        self.pov_DI = indicator_adx.adx_pos()
        self.neg_DI = indicator_adx.adx_neg()
        self.data['ADX_Signal'] = np.where((self.ADX > 25) & (self.pov_DI > self.neg_DI), 1, np.where((self.ADX > 25) & (self.neg_DI > self.pov_DI), -1, 0))
        return self.data

    def generate_cci_signals(self):
        self.cci = ta.trend.CCIIndicator(high=self.data['high'], low=self.data['low'], close=self.data['close'])
        self.data['CCI_Signal'] = np.where(self.cci.cci() > 100, 1, np.where(self.cci.cci() < -100, -1, 0))

    def generate_williams_r_signals(self):
        self.williams_r = ta.momentum.WilliamsRIndicator(high=self.data['high'], low=self.data['low'], close=self.data['close'])
        self.data['Williams_R_Signal'] = np.where(self.williams_r.williams_r() > -20, 1, np.where(self.williams_r.williams_r() < -80, -1, 0))
        return self.data

    def generate_donchian_channels_signals(self):
        self.Donchian_Median = (self.data['high'].rolling(window=20).max() + self.data['low'].rolling(window=20).min()) / 2
        self.data['Donchian_Signal'] = np.where(self.data['close'] > self.Donchian_Median, 1,np.where(self.data['close'] < self.Donchian_Median, -1, 0))
        return self.data

    def generate_elliott_wave(self):
        self.data['Elliott_Wave_Signal'] = np.where(self.data['close'] > self.data['close'].shift(1), 1,
                                                    np.where(self.data['close'] < self.data['close'].shift(1), -1, 0))
        return self.data

    def generate_price_action_signals(self):
        ranges = self.data['high'] - self.data['low']
        bullish_engulfing = (self.data['close'] > self.data['close'].shift(1)) & (self.data['close'].shift(1) < self.data['close'].shift(2)) & (self.data['close'] > self.data['close'].shift(2))
        bearish_engulfing = (self.data['close'] < self.data['close'].shift(1)) & (self.data['close'].shift(1) > self.data['close'].shift(2)) & (self.data['close'] < self.data['close'].shift(2))
        inside_bar = (self.data['close'] < self.data['close'].shift(1) - ranges.shift(1)) & (self.data['close'] > self.data['close'].shift(1) + ranges.shift(1))
        self.data['Price_Action_Signal'] = np.where(bullish_engulfing, 1, np.where(bearish_engulfing, -1, np.where(inside_bar, 2, 0)))
        return self.data

    def generate_strategy_signals(self):
        self.generate_atr_signals()
        # self.generate_pivot_signals()
        self.generate_ema50_200_crossover_signals()
        self.generate_ma30_100_crossover_signals()
        self.generate_rsi_signals()
        self.generate_ema_rsi_atr_signals()
        self.generate_macd_rsi_signal()
        self.generate_macd_rsi_bb_signal()
        self.generate_adx_vwap_ma50_signal()
        self.generate_gann_signal()
        # self.generate_rsi_divergence_signals()
        self.generate_macd_signals()
        self.generate_macd_histogram_signals()
        self.generate_bollinger_bands_signals()
        self.generate_stochastic_signals()
        self.generate_fibonacci_retracement_signals()
        self.generate_ichimoku_cloud_signals()
        self.generate_parabolic_sar_signals()
        self.generate_obv_signals()
        self.generate_adx_signals()
        self.generate_cci_signals()
        self.generate_williams_r_signals()
        self.generate_donchian_channels_signals()
        self.generate_elliott_wave()
        self.generate_price_action_signals()
        self.data= self.data.drop(['spread', 'real_volume'], axis=1)
        self.data = self.data.dropna()

        return self.data
    #?_______________________________________________________________________________________
    def dataframe_converting_for_XY(self, required):
        self.data = self.data.dropna()
        self.data[required+"_Y"] = self.data[required].shift(-1)
        self.data = self.data.dropna()

        y = pd.DataFrame()
        y[required+"_Y"] = self.data[required+"_Y"]

        first_column = self.data.pop('time')
        self.data.insert(0, 'time', first_column)
        self.data = self.data.drop(required+"_Y", axis=1)
        print(self.data.tail()), print(y.tail())
        return self.data, y
#*_________________________________________________________________________________________________________________________________________________
class TimeManager:
    def __init__(self):
        self.dic = {'IC': 'Europe/Moscow', 'NYC': 'US/Eastern', 'LON': 'Europe/London', 'SYD': 'Australia/Sydney',
                    'TOK': 'Asia/Tokyo'}

    def time_print(self, location_no=0):
        datetime_icmarket = datetime.now(pytz.timezone(self.dic[list(self.dic)[location_no]]))
        print("icmarket time:", datetime_icmarket.strftime("%H:%M:%S"))

    def new_hour(self, min=10):
        if min == datetime.now().minute:
            print('go_ahead')
        else:
            print('keep_running')

    def location_time(self, location_no=0):
        nyc_datetime_T = datetime.now(pytz.timezone(self.dic[list(self.dic)[location_no]])).strftime(
            '%Y-%m-%d %H:%M:%S')
        return nyc_datetime_T

    def location_hour(self, location_no=0):
        nyc_datetime_H = datetime.now(pytz.timezone(self.dic[list(self.dic)[location_no]])).hour
        return nyc_datetime_H

    def location_min(self, location_no=0):
        nyc_datetime_M = datetime.now(pytz.timezone(self.dic[list(self.dic)[location_no]])).minute
        return nyc_datetime_M

    def sys_min(self):
        return datetime.now().minute

    def sys_hour(self):
        return datetime.now().hour

    def dif_hr_4m_ICM(self, location_no=0):
        dif_1 = self.location_hour(location_no) - self.location_hour(0)
        return dif_1

    def diff_of_Market_from_given_hours(self, location_no=0, Given_Hour=0):
        Model = self.dif_hr_4m_ICM(location_no)
        Time_Setting = 0 if Model > 0 else 24
        P_24 = Given_Hour + Model if Time_Setting == 24 else 0
        Setting_24 = 24 + Model + Given_Hour if (Time_Setting == 24 and P_24 < 0) else P_24
        P_0 = Given_Hour + Model if Time_Setting == 0 else 0
        Setling_0 = P_0 - 23 if P_0 > 24 else P_0
        Join = Setting_24 + Setling_0
        Final_Join = 0 if Join == 24 else Join
        return Final_Join

    def market_open(self, location_no=0, Given_Hour=0):
        NYC = self.diff_of_Market_from_given_hours(location_no, Given_Hour)
        NYC_Open = 1 if 7 < NYC < 18 else 0
        return NYC_Open

    def New_Hour_starts(self, min):
        return 'go_ahead' if (min == datetime.now().minute) else 'keep_running'

    def Current_Time(self, Country='Europe/Moscow'):
        tz_icmarket = pytz.timezone(Country)
        datetime_icmarket = datetime.now(tz_icmarket)
        print("ICmarket Current Time is:", datetime_icmarket.strftime("%H:%M:%S"))

    def get_current_time_number(self):
        import time
        current_time = time.time()
        return current_time

    def convert_datetime_to_number(self, datetime_str):
        try:
            dt = datetime.strptime(datetime_str, "%Y-%m-%d %H:%M:%S")
            timestamp = dt.timestamp()
            return timestamp
        except ValueError:
            print("Invalid datetime format")
            return None
#*_________________________________________________________________________________________________________________________________________________
class Eco_Calendar:
    def Cleaning_EC_Data(self, data, column, folder):
        data[column] = data[column].astype(str)
        data[column] = [x.replace(',', '') for x in data[column]]
        data['T_'+column] = data[column].apply(lambda x: float(x.replace('T', ''))*1000000000000 if 'T' in x else None) 
        data['B_'+column] = data[column].apply(lambda x: float(x.replace('B', ''))*1000000000 if 'B' in x else None) 
        data['M_'+column] = data[column].apply(lambda x: float(x.replace('M', ''))*1000000 if 'M' in x else None) 
        data['K_'+column] = data[column].apply(lambda x: float(x.replace('K', ''))*1000 if 'K' in x else None) 
        data['%_'+column] = data[column].apply(lambda x: float(x.replace('%', ''))/100 if '%' in x else None) 
        data['n_'+column] = np.where(data['T_'+column].isnull() & data['B_'+column].isnull() & data['M_'+column].isnull() & data['K_'+column].isnull() & data['%_'+column].isnull(), data[column], 0)
        data['T_'+column] = data['T_'+column].fillna(0)
        data['B_'+column] = data['B_'+column].fillna(0)
        data['M_'+column] = data['M_'+column].fillna(0)
        data['K_'+column] = data['K_'+column].fillna(0)
        data['%_'+column] = data['%_'+column].fillna(0)
        data.to_csv(folder+'EC_2_Previous_Data.csv', index=False)
        data2 = pd.read_csv(folder+'EC_2_Previous_Data.csv')
        data2['F_'+column] = data2['T_'+column] + data2['B_'+column] + data2['M_'+column] + data2['K_'+column] + data2['%_'+column] + data2['n_'+column]
        data2.drop(['T_'+column, 'B_'+column, 'M_'+column, 'K_'+column, '%_'+column, 'n_'+column], axis=1, inplace=True)
        return data2

    def Investing_Economical_Calendar_N_Previous_days(self, Days_Back, folder):
        from_date = (dt.datetime.now() - dt.timedelta(days=Days_Back)).strftime('%d/%m/%Y')
        to_date = dt.datetime.now().strftime('%d/%m/%Y')
        ec = investpy.news.economic_calendar(time_zone='GMT +5:00', time_filter='time_only', countries=None, importances=['high', 'medium', 'low'], categories=None, from_date=from_date, to_date=to_date)
        ec.drop(ec.loc[ec['time'] == 'All Day'].index, inplace=True)
        ec.drop(ec.loc[ec['time'] == 'Tentative'].index, inplace=True)
        ec.drop(ec.loc[ec['date'] == from_date].index, inplace=True)
        ec.drop(ec.loc[ec['currency'].isnull()].index, inplace=True)
        ewd = ec["date"].str.split(r"/", expand=True)
        ec['datetime'] = ewd[2] + '-' + ewd[1] + '-' + ewd[0] + ' ' + ec['time'] + ':00'
        ec['datetime'] = pd.to_datetime(ec['datetime'])
        return ec.to_csv(folder + 'EC_0_Raw_Data.csv', index=False)

    def Ecomonical_Cleaned_Data(self, Days_Back, folder, Ret_Pattern):
        self.Investing_Economical_Calendar_N_Previous_days(Days_Back, folder)

        if Ret_Pattern == 'Current_fiie':
            ec = pd.read_csv(folder + 'EC_0_Raw_Data.csv')
            eco_Symbol_Sort = ['CAD', 'USD', 'JPY', 'CHF', 'AUD', 'NZD', 'EUR', 'GBP', 'SGD']
            ec.drop(ec.loc[~ec['currency'].isin(eco_Symbol_Sort)].index, inplace=True)
            ec.to_csv(folder + 'EC_1_Currency_Sorted_Data.csv', index=False)
            ed = pd.read_csv(folder + 'EC_1_Currency_Sorted_Data.csv')
            upcoming_news, previous_data, upcoming_speak, upcoming_value = ed, ed, ed, ed
            upcoming_news, previous_data = previous_data[previous_data['actual'].isnull()], previous_data[~previous_data['actual'].isnull()]
            upcoming_speak, upcoming_value = upcoming_speak[upcoming_speak['previous'].isnull()], upcoming_value[~upcoming_value['previous'].isnull()]
            previous_data = self.Cleaning_EC_Data(previous_data, 'actual', folder)
            previous_data = self.Cleaning_EC_Data(previous_data, 'previous', folder)
            upcoming_value.to_csv(folder + 'EC_3_Upcoming_Value_data.csv', index=False)
            upcoming_speak.to_csv(folder + 'EC_3_Upcoming_speak_data.csv')
            previous_data.to_csv(folder + 'EC_2_Previous_Data.csv', index=False)
            upcoming_news.to_csv(folder + 'EC_3_Upcoming_Events.csv', index=False)

        elif Ret_Pattern == 'For_Model':
            self.Ecomonical_Cleaned_Data(Days_Back, folder, Ret_Pattern='Current_fiie')
            ec             = pd.read_csv(folder + 'EC_1_Currency_Sorted_Data.csv')
            ec['datetime'] = pd.to_datetime(ec['datetime']).sub(pd.Timedelta('1ns')).dt.round(freq='1h')
            ec.groupby(['currency', 'importance', 'datetime'])['importance'].agg(['count']).to_csv(folder + 'EC_6_sorting_currency_importance_datetime.csv')
            ec6            = pd.read_csv(folder + 'EC_6_sorting_currency_importance_datetime.csv')
            ec6            = pd.get_dummies(ec6, columns=['importance', 'currency'], drop_first=False)
            ec6['datetime'] = pd.to_datetime(ec6['datetime'])
            ec6.to_csv(folder + 'EC_7_Sorted.csv')
            ec6            = ec6.groupby('datetime').sum()
            ec6.to_csv(folder + 'EC_7_Sorted_by_Date.csv')
            ec7            = pd.read_csv(folder + 'EC_7_Sorted_by_Date.csv')
            ec7['datetime'] = pd.to_datetime(ec7['datetime'])
            ec7.to_csv(folder + 'EC_7_Sorted_by_Date.csv', index=False)
            return ec7

    def Final_Output_Of_EC(self):
        self.Ecomonical_Cleaned_Data()
        ue, pe = pd.read_csv('EC_3_Upcoming_Value_data.csv'), pd.read_csv('EC_2_Previous_Data.csv')
        current = dt.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        ue['time'] = pd.to_datetime(ue["time"])
        ue['time'] = pd.to_datetime(ue['time'], format="%Y-%m-%d %H:%M:%S")
        ue['milliseconds'] = ue['time'].apply(lambda x: int(round(x.timestamp())))
        c_t = int(dt.datetime.now().timestamp())
        sleeptime = round(int(ue['milliseconds'].iloc[0] - c_t) / 100, 0) if round(int(ue['milliseconds'].iloc[0] - c_t) / 100, 0) > 0 else 60
        print(f'current={current}, c_t={c_t}, sleeptime={sleeptime}')
        isnull0 = pe['F_actual'].isnull().iloc[-1]
        news_currency = pe['currency'].iloc[-1]
        actual = pe['F_actual'].iloc[-1]
        previous = pe['F_previous'].iloc[-1]
        level_of_news = pe['importance'].iloc[-1]
        print(isnull0, news_currency, level_of_news, actual, previous, sleeptime)
        return isnull0, news_currency, level_of_news, actual, previous, sleeptime

    #?_______________________________________________________________________________________
    def Investing_Economical_Calendar_Today(self):
        Days_Back = 1
        from_date = (dt.datetime.now() - dt.timedelta(days=Days_Back)).strftime('%d/%m/%Y')
        to_date = dt.datetime.now().strftime('%d/%m/%Y')
        ec = investpy.economic_calendar(time_zone='GMT +5:00', from_date=from_date, to_date=to_date)
        ec.drop(ec.loc[ec['time'] == 'All Day'].index, inplace=True)
        ec.drop(ec.loc[ec['time'] == 'Tentative'].index, inplace=True)
        ec.drop(ec.loc[ec['date'] == from_date].index, inplace=True)
        return ec.to_csv('EC_0_Raw_Data.csv', index=False)

    def Importing_Economical_Calendar(self, file):
        ec = pd.read_csv(file + '.csv', index_col=False)
        ec.drop(ec.loc[ec['time'] == 'All Day'].index, inplace=True)
        ec['DateAndTime'] = ec['date'].str.cat(ec['time'], sep=" ")
        ec['DateAndTime'] = pd.to_datetime(ec['DateAndTime'])
        ec['DateAndTime'] = ec['DateAndTime'].dt.strftime('%Y-%d-%m %H:%M:%S')
        return ec

    def Importing_Data_From_Dir(self, file):
        data = pd.read_csv(file + '.csv', index_col=False)
        data['DateAndTime'] = data['time']
        data['DateAndTime'] = pd.to_datetime(data['DateAndTime'])
        return data
    
    def Merging_EC_Data(self, file_1, file_2):
        data = self.Importing_Data_From_Dir(file_1)
        ec = self.Importing_Economical_Calendar(file_2)
        result = data.append([ec])
        result['currency_base'] = result['currency_base'].fillna(method='ffill')
        result['currency_profit'] = result['currency_profit'].fillna(method='ffill')
        result["DateAndTime"] = result["DateAndTime"].astype('datetime64[ns]')
        result.sort_values(by='DateAndTime', inplace=True)
        result["currency_base"] = result["currency_base"].astype('str')
        result["currency_profit"] = result["currency_profit"].astype('str')
        result["currency"] = result["currency"].astype('str')
        result['isin'] = result.apply(lambda row: row['close'] > 0 or row['currency_base'] in row['currency'] or row['currency_profit'] in row['currency'], axis=1).astype(int)
        result = result[result['isin'] != 0]
        result = result.drop(['time', 'date', 'zone', 'currency_base', 'currency_profit'], axis=1)
        result.to_csv('result.csv', index=False)
        return result

# eco_calendar = Eco_Calendar()

# # Call the Final_Output_Of_EC() method
# eco_calendar.Final_Output_Of_EC()
#*_________________________________________________________________________________________________________________________________________________
class NNTrainer:
    def __init__(self, symbol, required, model_type, epx=5, addition_data_type='25_Strtegy',  training_camp='Scaled'):
        self.symbol = symbol
        self.required = required
        self.model_type = model_type
        self.data_folder = 'ICMarketsSC_P_Data_Forex/'
        self.epx = epx
        # self.data_set_select = data_set_selection
        self.addition_data_type = addition_data_type
        self.training_camp = training_camp

        self.model_folder = 'Saving_Model/'
        self.model_file = symbol
    
    def train_NN(self):
        dataframe = self._load_dataframe()
        x_data, y_data = self._add_indicator_to_dataframe(dataframe)
        x, y = self._prepare_data(x_data, y_data)

        self._train_model_nn_check(x, y)
        print(f'Training is complete for {self.model_type} of symbol {self.model_file} with column name {self.required}')
        print('_______________________________________________________________________________________________________')
    
    def _load_dataframe(self):
        return pd.read_csv(self.data_folder + self.model_file + ".csv")
    
    def _add_indicator_to_dataframe(self, dataframe):
        print('________________________________________________________________________________________________________________ Calling the Raw Data')
        print(dataframe.tail(5))

        print('________________________________________________________________________________________________________________ Adding the Strategies Indicator')
        data = MultiplesStrategiesSignal(dataframe).generate_strategy_signals()                       #~ Have to add here the list of 
        print(data.tail(5))

        #? Saving the data into Folder For checking 
        path = 'E:\\Code - D\\Programming Codes\\Python_Learning\\My Stocks Working\\MT5_with_python\\M001_NEW_STRATEGIES_METATRADER5\\'
        data_for_prediction = 'Data_For_Train/'
        data.to_csv(path+data_for_prediction+self.symbol+'.csv', index=False)

        print('________________________________________________________________________________________________________________ Converting Data Data_X and Data_Y')
        x_data, y_data = MultiplesStrategiesSignal(data).dataframe_converting_for_XY(self.required)
        print(f'Adding the Indicator the Data - X_Data={x_data.shape}, Y_Data={y_data.shape}')
        return x_data, y_data
    
    def _prepare_data(self, x_data, y_data):
        if self.training_camp == 'not_Scaled':
            print(' --- CONVERTING INTO NUMPY ---') 
            x_data, y_data = x_data.to_numpy(), y_data.to_numpy()

            print(' --- Converting the Data Dimension ---') 
            dates, x, y = self._convert_data_to_numpy(x_data, y_data, '3rd')
            return x, y
        
        elif self.training_camp == 'Scaled':
            print('________________________________________________________________________________________________________________ Scaling the Data  - Modeling Phase') 
            scaler = MinMaxScaler()
            scaled_x_data = scaler.fit_transform(x_data)
            scaled_y_data = scaler.fit_transform(y_data)
            # scaled_y_data = scaler.transform(y_data)  # Use transform instead of fit_transform
            print(f'Scaled_X_Data={scaled_x_data.shape}, Scaled_Y_Data={scaled_y_data.shape}')

            print('________________________________________________________________________________________________________________ Converting the Data Dimension - Modeling Phase') 
            dates, x, y = self._convert_data_to_numpy(scaled_x_data, scaled_y_data, '3rd')
            # print(dates), print(x)
            print(f'________________________________________________________________________________________________________________ dates={dates.shape}, X={x.shape}, Y={y.shape}')
            return x, y

    def _convert_data_to_numpy(self, x_data, y_data, type_need='3rd'):
        print(f'X_Data.shape={x_data.shape}, Y_Data.shape={y_data.shape}')
        
        if type_need == '1st':
            df_as_np_x = x_data
            df_as_np_y = y_data
            dates = df_as_np_x[:, 0]
            middle_matrix = df_as_np_x[:, 1:-1]
            x = middle_matrix.reshape((len(dates), middle_matrix.shape[1], 1))
            y = df_as_np_y[:, -1]
            print(f'dates.shape={dates.shape}, X.shape={x.shape}, Y.shape={y.shape}')
            return dates, x.astype(np.float32), y.astype(np.float32)

        elif type_need == '2nd':
            df_as_np_x = x_data
            df_as_np_y = y_data
            dates = df_as_np_x[:, 0]
            middle_matrix = df_as_np_x[:, 1:-1]
            x = middle_matrix.reshape((len(dates), middle_matrix.shape[1], 1))
            y = df_as_np_y[:]
            print(f'dates.shape={dates.shape}, X.shape={x.shape}, Y.shape={y.shape}')
            return dates, x.astype(np.float32), y.astype(np.float32)

        elif type_need == '3rd':
            dates           = x_data[:, 0]
            middle_matrix   = x_data[:, 1:]
            x = middle_matrix.reshape((len(dates), middle_matrix.shape[1], 1))
            y = y_data[:, -1]

            print(f'dates.shape={dates.shape}, X.shape={x.shape}, Y.shape={y.shape}')
            return dates.astype(np.float64), x.astype(np.float32), y.astype(np.float32)

    def _configure_multi_device(self):
        # Check available devices
        devices = device_lib.list_local_devices()
        print(devices)

        # Set the list of device names to be used
        device_names = ['CPU', 'GPU:0']  # Modify the device names as per your requirements

        # Create a distributed strategy to utilize multiple devices
        strategy = tf.distribute.MirroredStrategy(devices=device_names)

        return strategy

    def _train_model_nn_check(self, x, y):
        num_rows_x, num_cols_x, num_datas_x = x.shape
        print(f'Data.shape={x.shape}, y.shape={y.shape}')
        model, num_timesteps, num_features = None, num_cols_x, 1

        physical_devices = tf.config.list_physical_devices('GPU')
        tf.config.experimental.set_memory_growth(physical_devices[0], True)

        with tf.device('/GPU:0'):
            model = Sequential()
            if self.model_type == 'LGD2048':
                model.add(LSTM(2048, return_sequences=True, input_shape=(num_timesteps, num_features)))
                model.add(Dropout(0.2))
                model.add(LSTM(128, return_sequences=True))
                model.add(Dropout(0.2))
                model.add(GRU(64, return_sequences=True))
                model.add(GRU(32, return_sequences=True))
                model.add(Dense(32, activation='relu'))
                model.add(Dense(1, activation='sigmoid'))
                model.compile(loss='mse', optimizer=Adam(learning_rate=0.00001), metrics=['mse'])

            elif self.model_type == 'G1024':
                model.add(GRU(512, input_shape=(num_timesteps, num_features)))
                # model.add(GRU(256, return_sequences=True))
                model.add(Dense(1, activation='sigmoid'))
                # model.add(Dense(1, activation='relu'))
                model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])
                # model.compile(loss='mse', optimizer=Adam(learning_rate=0.0001), metrics=['mse'])

            elif self.model_type == 'L1024':
                model.add(LSTM(1024, return_sequences=True, input_shape=(num_timesteps, num_features)))
                model.add(LSTM(256, return_sequences=True))
                model.add(LSTM(64, return_sequences=True))
                model.add(Dense(16, activation='relu'))
                model.add(Dense(4, activation='relu'))
                model.add(Dense(1, 'linear'))
                model.compile(loss='mse', optimizer=Adam(learning_rate=0.00001), metrics=['mse'])
                # model.compile(loss='mse', optimizer='adam')

            elif self.model_type == 'LD1024':
                model.add(LSTM(1024, return_sequences=True, input_shape=(num_timesteps, num_features)))
                model.add(LSTM(128, return_sequences=True))
                model.add(LSTM(32, return_sequences=True))
                model.add(LSTM(8, return_sequences=True))
                model.add(LeakyReLU())
                model.add(Dense(1, 'linear'))
                model.compile(loss='mse', optimizer='adam')

            elif self.model_type == 'R1024':
                model.add(SimpleRNN(1024, input_shape=(num_timesteps, num_features)))
                model.add(Dense(1))
                model.compile(loss='mse', optimizer='adam')

            elif self.model_type == 'TLD512':
                model.add(TimeDistributed(Dense(512, activation='relu'), input_shape=(num_timesteps, num_features)))
                model.add(TimeDistributed(Dense(256, activation='relu')))
                model.add(LSTM(512))
                model.add(Dense(1))
                model.compile(loss='mse', optimizer='adam')

            elif self.model_type == 'Multi': #* Matched is more then 80 %
                model.add(LSTM(1024, return_sequences=True, input_shape=(num_timesteps, num_features)))
                model.add(GRU(512, return_sequences=True))
                model.add(GRU(256, return_sequences=True))
                model.add(LSTM(128, return_sequences=True))
                model.add(Dense(16, activation='relu'))
                model.add(Dense(8, activation='relu'))
                model.add(LeakyReLU())
                model.add(Flatten())
                model.add(Dense(1, 'linear'))
                model.compile(loss='mse', optimizer=Adam(learning_rate=0.0001), metrics=['mse'])
    

            if self.training_camp == 'Scaled':
                q_85 = int(len(x) * 0.85)
                q_95 = int(len(x) * 0.95)

                dates_train, x_train, y_train = x[:q_85], x[:q_85], y[:q_85]
                dates_val, x_val, y_val = x[q_85:q_95], x[q_85:q_95], y[q_85:q_95]

            x_train, y_train    = tf.convert_to_tensor(x_train, dtype=tf.float32), tf.convert_to_tensor(y_train, dtype=tf.float32)
            x_val, y_val        = tf.convert_to_tensor(x_val, dtype=tf.float32), tf.convert_to_tensor(y_val, dtype=tf.float32)

            model.fit(x_train, y_train, validation_data=(x_val, y_val), epochs=self.epx, batch_size=1)
            model.save(self.model_folder + self.model_file + '_' + self.required + '_' + self.model_type + '_' + self.training_camp + '_' + self.addition_data_type + '.h5')
            sleep(5)

    def _train_model_nn_cpu(self, x, y):
        num_rows_x, num_cols_x, num_datas_x = x.shape
        print(f'Data.shape={x.shape}, y.shape={y.shape}')
        act = 'relu'

        if self.model_type == 'L128':
            model = Sequential([layers.LSTM(128, return_sequences=True, input_shape=(num_cols_x,1)),
                                layers.LSTM(64, return_sequences=True),
                                layers.LSTM(32, return_sequences=False),
                                layers.Dense(32, activation=act),
                                layers.Dense(16, activation=act),
                                layers.Dense(4, activation=act),
                                layers.Flatten(),
                                layers.Dense(1)])

        elif self.model_type == 'L512':
            model = Sequential([layers.Input((num_cols_x, 1)),
                                layers.LSTM(512),
                                layers.Dense(256, activation=act),
                                layers.Dense(128, activation=act),
                                layers.Dense(64, activation=act),
                                layers.Dense(32, activation=act),
                                layers.Dense(16, activation=act),
                                layers.Dense(8, activation=act),
                                layers.Dense(4, activation=act),
                                layers.Flatten(),
                                layers.Dense(1)])

        elif self.model_type == 'L512F':
            model = Sequential([layers.Input((num_cols_x, 1)),
                                layers.LSTM(512),
                                layers.Flatten(),
                                layers.Dense(256, activation=act),
                                layers.Flatten(),
                                layers.Dense(128, activation=act),
                                layers.Flatten(),
                                layers.Dense(64, activation=act),
                                layers.Flatten(),
                                layers.Dense(32, activation=act),
                                layers.Flatten(),
                                layers.Dense(16, activation=act),
                                layers.Flatten(),
                                layers.Dense(8, activation=act),
                                layers.Flatten(),
                                layers.Dense(4, activation=act),
                                layers.Flatten(),
                                layers.Dense(1)])

        elif self.model_type == 'L1024':
            model = Sequential([layers.LSTM(1024, return_sequences=True, input_shape=(num_cols_x,1)),
                                layers.LSTM(512, return_sequences=False),
                                layers.Dense(256, activation=act),
                                layers.Dense(128, activation=act),
                                layers.Dense(64, activation=act),
                                layers.Dense(32, activation=act),
                                layers.Dense(16, activation=act),
                                layers.Dense(8, activation=act),
                                layers.Dense(4, activation=act),
                                layers.Flatten(),
                                layers.Dense(1)])

        elif self.model_type == 'L1024F':
            model = Sequential([layers.LSTM(1024, return_sequences=True, input_shape=(num_cols_x,1)),
                                layers.Flatten(),
                                layers.LSTM(512, return_sequences=False),
                                layers.Flatten(),
                                layers.Dense(256, activation=act),
                                layers.Flatten(),
                                layers.Dense(128, activation=act),
                                layers.Flatten(),
                                layers.Dense(64, activation=act),
                                layers.Flatten(),
                                layers.Dense(32, activation=act),
                                layers.Flatten(),
                                layers.Dense(16, activation=act),
                                layers.Flatten(),
                                layers.Dense(8, activation=act),
                                layers.Flatten(),
                                layers.Dense(4, activation=act),
                                layers.Flatten(),
                                layers.Dense(1)])

        elif self.model_type == "C2048":
            model = Sequential([layers.InputLayer((num_cols_x, 1)),
                                layers.Conv1D(2048, kernel_size=2),
                                layers.Dense(1024, activation=act),
                                layers.Dense(512, activation=act),
                                layers.Dense(256, activation=act),
                                layers.Dense(128, activation=act),
                                layers.Dense(64, activation=act),
                                layers.Dense(32, activation=act),
                                layers.Dense(16, activation=act),
                                layers.Dense(8, activation=act),
                                layers.Dense(4, activation=act),
                                layers.Flatten(),
                                layers.Dense(1, 'linear')])

        elif self.model_type == "C2048F":
            model = Sequential([layers.InputLayer((num_cols_x, 1)),
                                layers.Conv1D(2048, kernel_size=2),
                                layers.Flatten(),
                                layers.Dense(1024, activation=act),
                                layers.Flatten(),
                                layers.Dense(512, activation=act),
                                layers.Flatten(),
                                layers.Dense(256, activation=act),
                                layers.Flatten(),
                                layers.Dense(128, activation=act),
                                layers.Flatten(),
                                layers.Dense(64, activation=act),
                                layers.Flatten(),
                                layers.Dense(32, activation=act),
                                layers.Flatten(),
                                layers.Dense(16, activation=act),
                                layers.Flatten(),
                                layers.Dense(8, activation=act),
                                layers.Flatten(),
                                layers.Dense(4, activation=act),
                                layers.Flatten(),
                                layers.Dense(1, 'linear')])

        elif self.model_type == "D2048":
            model = Sequential([layers.InputLayer((num_cols_x, 1)),
                                layers.Dense(2048, activation=act),
                                layers.Dense(1024, activation=act),
                                layers.Dense(512, activation=act),
                                layers.Dense(256, activation=act),
                                layers.Dense(128, activation=act),
                                layers.Dense(64, activation=act),
                                layers.Dense(32, activation=act),
                                layers.Dense(16, activation=act),
                                layers.Dense(8, activation=act),
                                layers.Dense(4, activation=act),
                                layers.Flatten(),
                                layers.Dense(1, 'linear')])

        elif self.model_type == "D2048F":
            model = Sequential([layers.InputLayer((num_cols_x, 1)),
                                layers.Dense(2048, activation=act),
                                layers.Flatten(),
                                layers.Dense(1024, activation=act),
                                layers.Flatten(),
                                layers.Dense(512, activation=act),
                                layers.Flatten(),
                                layers.Dense(256, activation=act),
                                layers.Flatten(),
                                layers.Dense(128, activation=act),
                                layers.Flatten(),
                                layers.Dense(64, activation=act),
                                layers.Flatten(),
                                layers.Dense(32, activation=act),
                                layers.Flatten(),
                                layers.Dense(16, activation=act),
                                layers.Flatten(),
                                layers.Dense(8, activation=act),
                                layers.Flatten(),
                                layers.Dense(4, activation=act),
                                layers.Flatten(),
                                layers.Dense(1, 'linear')])

        elif self.model_type == "G2048":
            model = Sequential([layers.InputLayer((num_cols_x, 1)),
                                layers.GRU(2048),
                                layers.Dense(1024, activation=act),
                                layers.Dense(512, activation=act),
                                layers.Dense(256, activation=act),
                                layers.Dense(128, activation=act),
                                layers.Dense(64, activation=act),
                                layers.Dense(32, activation=act),
                                layers.Dense(16, activation=act),
                                layers.Dense(8, activation=act),
                                layers.Dense(4, activation=act),
                                layers.Flatten(),
                                layers.Dense(1, 'linear')])

        elif self.model_type == "G2048F":
            model = Sequential([layers.InputLayer((num_cols_x, 1)),
                                layers.GRU(2048),
                                layers.Flatten(),
                                layers.Dense(1024, activation=act),
                                layers.Flatten(),
                                layers.Dense(512, activation=act),
                                layers.Flatten(),
                                layers.Dense(256, activation=act),
                                layers.Flatten(),
                                layers.Dense(128, activation=act),
                                layers.Flatten(),
                                layers.Dense(64, activation=act),
                                layers.Flatten(),
                                layers.Dense(32, activation=act),
                                layers.Flatten(),
                                layers.Dense(16, activation=act),
                                layers.Flatten(),
                                layers.Dense(8, activation=act),
                                layers.Flatten(),
                                layers.Dense(4, activation=act),
                                layers.Flatten(),
                                layers.Dense(1, 'linear')])

        elif self.model_type == "G512":
            model = Sequential([layers.InputLayer((num_cols_x, 1)),
                                layers.GRU(512),
                                layers.Dense(256, activation=act),
                                layers.Dense(128, activation=act),
                                layers.Dense(64, activation=act),
                                layers.Dense(32, activation=act),
                                layers.Dense(16, activation=act),
                                layers.Dense(8, activation=act),
                                layers.Dense(4, activation=act),
                                layers.Flatten(),
                                layers.Dense(1, 'linear')])

        elif self.model_type == 'Multi': #* Matched is more then 80 %
            model = Sequential([layers.InputLayer((num_cols_x,1)),
                                layers.Conv1D(filters = 1024, kernel_size=2, activation=act),
                                layers.Conv1D(filters = 512, kernel_size=2, activation=act),
                                layers.LeakyReLU(),
                                layers.LSTM(256, return_sequences=True),
                                layers.LSTM(128, return_sequences=True),
                                layers.LeakyReLU(),
                                layers.GRU(64, return_sequences=True),
                                layers.GRU(32, return_sequences=True),
                                layers.LeakyReLU(),
                                layers.Dense(16, activation=act),
                                layers.Dense(8, activation=act),
                                layers.LeakyReLU(),
                                layers.Flatten(),
                                layers.Dense(1, 'linear')])

        elif self.model_type == 'CLGD1024': #* Matched is more then 80 %
            model = Sequential([layers.InputLayer((num_cols_x,1)),
                                layers.Conv1D(filters = 1024, kernel_size=2, activation=act),
                                layers.Conv1D(filters = 512, kernel_size=2, activation=act),
                                layers.LeakyReLU(),
                                layers.LSTM(256, return_sequences=True),
                                layers.LSTM(128, return_sequences=True),
                                layers.LeakyReLU(),
                                layers.GRU(64, return_sequences=True),
                                layers.GRU(32, return_sequences=True),
                                layers.LeakyReLU(),
                                layers.Dense(16, activation=act),
                                layers.Dense(8, activation=act),
                                layers.LeakyReLU(),
                                layers.Flatten(),
                                layers.Dense(1, 'linear')])

        elif self.model_type == 'CGLD1024': #* Matched more then 70 %
            model = Sequential([layers.InputLayer((num_cols_x,1)),
                                layers.Conv1D(filters = 1024, kernel_size=2, activation=act),
                                layers.Conv1D(filters = 512, kernel_size=2, activation=act),
                                layers.LeakyReLU(),
                                layers.GRU(256, return_sequences=True),
                                layers.GRU(128, return_sequences=True),
                                layers.LeakyReLU(),
                                layers.LSTM(64, return_sequences=True),
                                layers.LSTM(32, return_sequences=True),
                                layers.LeakyReLU(),
                                layers.Dense(16, activation=act),
                                layers.Dense(8, activation=act),
                                layers.LeakyReLU(),
                                layers.Flatten(),
                                layers.Dense(1, 'linear')])

        elif self.model_type == 'CLD1024': #* Matched is more then 85 %
            model = Sequential([layers.InputLayer((num_cols_x,1)),
                                layers.Conv1D(filters = 1024, kernel_size=2, activation=act),
                                layers.Conv1D(filters = 512, kernel_size=2, activation=act),
                                layers.LeakyReLU(),
                                layers.LSTM(128, return_sequences=True),
                                layers.LSTM(64, return_sequences=True),
                                layers.LeakyReLU(),
                                layers.Dense(16, activation=act),
                                layers.Dense(8, activation=act),
                                layers.LeakyReLU(),
                                layers.Flatten(),
                                layers.Dense(1, 'linear')])

        elif self.model_type == 'CLD2048': #* Matched more then 85 %
            model = Sequential([layers.InputLayer((num_cols_x,1)),
                                layers.Conv1D(filters = 2048, kernel_size=4, activation=act),
                                layers.Conv1D(filters = 1024, kernel_size=2, activation=act),
                                layers.Conv1D(filters = 512, kernel_size=2, activation=act),
                                layers.LeakyReLU(),
                                layers.LSTM(256, return_sequences=True),
                                layers.LSTM(128, return_sequences=True),
                                layers.LSTM(64, return_sequences=True),
                                layers.LeakyReLU(),
                                layers.Dense(32, activation=act),
                                layers.Dense(16, activation=act),
                                layers.Dense(8, activation=act),
                                layers.LeakyReLU(),
                                layers.Flatten(),
                                layers.Dense(1, 'linear')])

        elif self.model_type == 'C4096_Flatten': #* Matched is 60 to 70 %
            model = Sequential([layers.InputLayer((num_cols_x,1)),
                                layers.Conv1D(4096, kernel_size=2),
                                layers.Flatten(),
                                layers.Dense(1024, activation=act),
                                layers.Flatten(),
                                layers.Dense(256, activation=act),
                                layers.Flatten(),
                                layers.Dense(64, activation=act),
                                layers.Flatten(),
                                layers.Dense(16, activation=act),
                                layers.Flatten(),
                                layers.Dense(4, activation=act),
                                layers.Flatten(),
                                layers.Dense(1, 'linear')])

        elif self.model_type == 'C4096_LeakyReLU': #* Matched is 60 to 70 %
            model = Sequential([layers.InputLayer((num_cols_x,1)),
                                layers.Conv1D(4096, kernel_size=2),
                                layers.LeakyReLU(),
                                layers.Dense(1024, activation=act),
                                layers.LeakyReLU(),
                                layers.Dense(256, activation=act),
                                layers.LeakyReLU(),
                                layers.Dense(64, activation=act),
                                layers.LeakyReLU(),
                                layers.Dense(16, activation=act),
                                layers.LeakyReLU(),
                                layers.Dense(4, activation=act),
                                layers.LeakyReLU(),
                                layers.Flatten(),
                                layers.Dense(1, 'linear')])

        model.compile(
            loss='mse',
            optimizer=Adam(learning_rate=0.00001),
            metrics=['mean_absolute_error']
        )

        if self.training_camp == 'Scaled':
            q_85 = int(len(x) * 0.85)
            q_95 = int(len(x) * 0.95)

            dates_train, x_train, y_train = x[:q_85], x[:q_85], y[:q_85]
            dates_val, x_val, y_val = x[q_85:q_95], x[q_85:q_95], y[q_85:q_95]


        model.fit(x_train, y_train, validation_data=(x_val, y_val), epochs=self.epx)
        model.save(self.model_folder + self.model_file + '_' + self.required + '_' + self.model_type + '_' + self.training_camp + '_' + self.addition_data_type + '.h5')

    def _further_data_extention_for_signal_management(self, data):
        point = MetaTraderHelper().get_point(self.symbol)

        data['Pre_'+self.required+'_to_Act_'+self.required] = (data['Act_Pre_'+self.required] - data['Act_'+self.required]) / point
        data['Pre_'+self.required+'_to_Pred_'+self.required] = (data['Act_Pre_'+self.required] - data['Pred_'+self.required]) / point

        Avg_Min_Max = round(sts.stdev(data['Pre_'+self.required+'_to_Pred_'+self.required]), -1)
        data['entry_point'] = np.where(data['Pre_'+self.required+'_to_Pred_'+self.required] > Avg_Min_Max, data['Pre_'+self.required+'_to_Pred_'+self.required], np.where(data['Pre_'+self.required+'_to_Pred_'+self.required] < (-Avg_Min_Max), data['Pre_'+self.required+'_to_Pred_'+self.required], 0))
        data['profit_checking'] = np.where((data['Signal_0'] == "buy") & (data['entry_point'] < 0), -data['entry_point'], np.where((data['Signal_0'] == "sell") & (data['entry_point'] > 0), data['entry_point'], 0))
        data['Act_profit'] = np.where(data['profit_checking'] > 0, Avg_Min_Max/100, 0)
        data['CUMSUM_Act_pro'] = data['Act_profit'].cumsum()
        
        data['Points_Tp_Sl'] = Avg_Min_Max
        data['Signal_1'] = np.where(data['Act_profit'] > 0, data['Signal_0'], None)

        data['chg_Pred_'+self.required] = data['Pred_'+self.required] - data['Pred_'+self.required].shift(1)
        data['chg_Act_'+self.required] = data['Act_'+self.required] - data['Act_'+self.required].shift(1)
        data['std_Act_chg'] = data['chg_Act_'+self.required].std()
        data['Match_of_chg'] = np.where(np.where(data['Pred_'+self.required].shift(1) < data['Pred_'+self.required].shift(0), "buy", "sell") == np.where(data['Act_'+self.required].shift(1) < data['Act_'+self.required].shift(0), "buy", "sell"), "Matched", "Not_Matched")
        data['Dif_Pred_chg_2_std'] = np.where(abs(data['chg_Pred_'+self.required]) > data['chg_Pred_'+self.required].std(), data['chg_Pred_'+self.required], 0)
        data['Dif_Act_chg_2_std'] = np.where(abs(data['chg_Act_'+self.required]) > data['chg_Act_'+self.required].std(), data['chg_Act_'+self.required], 0)
        data['Signal_2'] = np.where(data['Dif_Pred_chg_2_std'] > 0, 'buy', np.where(data['Dif_Pred_chg_2_std'] < 0, 'sell', None))
        data['TP_Value'] = np.where(data['Signal_2'] == 'sell', data['Act_'+self.required].shift(1) - data['chg_Act_'+self.required].std(), np.where(data['Signal_2'] == 'buy', data['Act_'+self.required].shift(1) + data['chg_Act_'+self.required].std(), 0))

        data['currency_base'] = mt5.symbol_info(self.symbol)._asdict()['currency_base']
        data['currency_profit'] = mt5.symbol_info(self.symbol)._asdict()['currency_profit']

        return data

    #&___________________________________________________________________________________________________________
    def _prediction_scaled(self, X_Data, Y_Data):
        date = X_Data['time']
        print(date.tail())
        print("________________________________________________________________________________________________________________ Scaling the Data - Prediction Phase")
        scale_mm = MinMaxScaler()
        print(f"legth of X_Data {len(X_Data)}, length of Y_Data {len(Y_Data)}")
        self.Scaled_Dataset = scale_mm.fit_transform(X_Data)
        self.Scaled_Required = scale_mm.fit_transform(Y_Data)
        print(f"Scaled_Dataset = {self.Scaled_Dataset.shape}")

        print("________________________________________________________________________________________________________________ Converting the Data Dimension - Prediction Phase")
        self.date, self.Dataframe, self.Actual = self._convert_data_to_numpy(self.Scaled_Dataset, self.Scaled_Required, '3rd')
        print(f"Date = {self.date.shape}, Dataframe = {self.Dataframe.shape}, Required = {self.Actual.shape}")

        print("________________________________________________________________________________________________________________ Getting the Prediction")
        Model         = load_model(f"{self.model_folder}{self.model_file}_{self.required}_{self.model_type}_{self.training_camp}_{self.addition_data_type}.h5")
        self.Pred_Val = Model.predict(self.Dataframe).flatten()
        print(self.Pred_Val)
        print(f"Prediction is complete for {self.model_type} of symbol {self.model_file} of the column {self.required}")

        print("________________________________________________________________________________________________________________ Inversing the Scaling of Prediction Data")
        self.Pred   = scale_mm.inverse_transform(np.reshape(self.Pred_Val, (self.Pred_Val.shape[0], 1))).flatten()
        self.Actual = scale_mm.inverse_transform(np.reshape(self.Actual, (self.Actual.shape[0], 1))).flatten()
        # self.Date   = scale_mm.inverse_transform(np.reshape(self.date, (self.date.shape[0], 1))).flatten()
        self.Date   = date
        
        print(f"Inversing the Scaling COMPLETE - Pred {self.Pred} - Actual {self.Actual} - Data {self.Date}")
        return self.Pred, self.Actual, self.Date

    def _prediction_not_scaled(self, X_Data, Y_Data):
        print("________________________________________________________________________________________________________________ Converting the Data Dimension")
        Date, Dataframe, Actual = self._convert_data_to_numpy(X_Data.to_numpy(), Y_Data.to_numpy(), '3rd')
        print(f"Date = {Date.shape}, Dataframe = {Dataframe.shape}, Required = {Actual.shape}")

        print("________________________________________________________________________________________________________________ Prediction")
        Model = load_model(f"{self.model_folder}{self.model_file}_{self.required}_{self.model_type}_{self.training_camp}_{self.addition_data_type}.h5")
        Pred = Model.predict(Dataframe).flatten()
        print(f"Prediction is complete for {self.model_type} of symbol {self.model_file} of the column {self.required}")

        return pd.DataFrame(Pred, columns=['Y_close'])

    def _create_actual_dataframe_for_prediction(self):
        df = pd.DataFrame()
        df['time'], df['Pred_' + self.required], df['Act_' + self.required],  = self.Date, self.Pred, self.Actual
        df['Act_Pre_' + self.required] = pd.Series(self.Actual).shift(1)

        df['dif_Pre_Pred']  = np.where(df['Pred_' + self.required].shift(1) < df['Pred_' + self.required].shift(0), "buy", "sell")
        df['dif_Act_Pred']  = np.where(df['Act_' + self.required].shift(1) < df['Act_' + self.required].shift(0), "buy", "sell")
        df['Match']         = np.where(df['dif_Pre_Pred'] == df['dif_Act_Pred'], "Matched", "Not_Matched")
        df['Dif_Pred_Act']  = df['Pred_' + self.required] - df['Act_' + self.required]
        df['Signal_0']      = df['dif_Pre_Pred']
        return df

    def _create_modeling_dataframe_for_prediction(self):
        df = pd.DataFrame()
        df['time'] = self.Date[:len(self.Date)]
        df['Pred_' + self.required] = self.Pred[:len(self.Date)]
        df['Act_' + self.required] = self.Actual[:len(self.Date)]
        df['Act_Pre_' + self.required] = pd.Series(self.Actual[:len(self.Date)]).shift(1)

        df['dif_Pre_Pred']  = np.where(df['Pred_' + self.required].shift(1) < df['Pred_' + self.required].shift(0), "buy", "sell")
        df['dif_Act_Pred']  = np.where(df['Act_' + self.required].shift(1) < df['Act_' + self.required].shift(0), "buy", "sell")
        df['Match']         = np.where(df['dif_Pre_Pred'] == df['dif_Act_Pred'], "Matched", "Not_Matched")
        df['Dif_Pred_Act']  = df['Pred_' + self.required] - df['Act_' + self.required]
        df['Signal_0']      = df['dif_Pre_Pred']
        return df

    def _merge_with_economic_calendar(self, df):
        folder_eco = './Eco_Cal_Prediction/'
        ec = pd.read_csv(folder_eco + 'EC_7_Sorted_by_Date.csv')
        ec['datetime'] = pd.to_datetime(ec['datetime'], format='%Y-%m-%d %H:%M:%S')
        df = pd.merge(left=df, right=ec, how='left', left_on='datetime', right_on='datetime')
        df = df.fillna(0)
        df.sort_values(by='datetime', inplace=True)
        return df

    def _finalize_result(self, df):
        Pred_Save_Folder, Pred = 'Prediction_Folder/', []
        df.to_csv(f"{Pred_Save_Folder}{self.model_file}_{self.required}_{self.model_type}_{self.training_camp}_{self.addition_data_type}_Single_Column_Pred.csv", index=False)
        print(df.tail(5))
        print("________________________________________________________________________________________________________________ Prediction completed.")

        count_Of_Match_out_of_total = (df['Match'].value_counts(normalize=True) * 100).loc['Matched']
        Max_Dif                     = abs(df['Dif_Pred_Act']).max()
        Min_Dif                     = abs(df['Dif_Pred_Act']).min()
        std                         = df['Dif_Pred_Act'].std()
        print(f"Percentage of Matched: {count_Of_Match_out_of_total}, Max Difference in Act to Pred: {Max_Dif}, Min Difference in Act to Pred: {Min_Dif}, The Stradard Deviation in Act to Pred: {std}")
        return count_Of_Match_out_of_total, Max_Dif, Min_Dif, std

    def _make_prediction_on_dataframe_nn(self, Prediction_for='Actual'):
        if Prediction_for == "Model":
            print("________________________________________________________________________________________________________________ Creating *Modeling Dataframe* for Prediction")
            df = self._create_modeling_dataframe_for_prediction()
        elif Prediction_for == "Actual":
            print("________________________________________________________________________________________________________________ Creating *Actual Dataframe* for Prediction")
            df = self._create_actual_dataframe_for_prediction()

        print("________________________________________________________________________________________________________________ Extend Data for Signal Management")
        df = self._further_data_extention_for_signal_management(df)
        print("________________________________________________________________________________________________________________ Adding Maket Opening Time")
        df = MultiplesStrategiesSignal(data=df).market_opening_time()
        print("________________________________________________________________________________________________________________ Finalizing the Result")
        count_Of_Match_out_of_total, Max_Dif, Min_Dif, std = self._finalize_result(df)
        return count_Of_Match_out_of_total, std

    def prediction_nn_pack(self, X_Data, Y_Data, Result_Type, nth=10):
        print("________________________________________________________________________________________________________________ Starting the Prediction...")
        Pred_Save_Folder = "Prediction_Folder/"

        if self.training_camp == 'Scaled':
            self.Pred, self.Actual, self.Date = self._prediction_scaled(X_Data, Y_Data)

        elif self.training_camp == 'not_Scaled':
            self.Pred = self._prediction_not_scaled(X_Data, Y_Data)

        if Result_Type == 'Pred_Result':
            return pd.DataFrame(self.Pred, columns=['Y_close'])

        elif Result_Type == 'Unlimited_Pred_Result':
            obj, Y_close, time = {}, [], []
            for i in range(len(X_Data.columns)):
                obj[X_Data.columns[i]] = X_Data[X_Data.columns[i]].to_numpy()
            del obj['time']
            Y_close = Y_Data.to_numpy()
            time = X_Data['time'].to_numpy()
            for i in range(nth):
                D_Data = pd.DataFrame(obj)
                D_Data.insert(0, 'time', time, allow_duplicates=False)
                Pred = self.prediction_nn_pack(D_Data, Y_Data, self.required, 'Prediction_Result', self.model_folder, self.model_file, self.model_type, self.training_camp, nth)
                Y_close = np.append(Y_close, Pred['Y_close'].iloc[-1])
                time = np.append(time, time[-1] + 900)
                for k in range(len(list(obj))):
                    obj[list(obj)[k]] = np.append(obj[list(obj)[k]], Y_close[-(1 + len(obj) - k)])

            Z_Data = pd.DataFrame(obj)
            Z_Data.insert(0, 'time', time, allow_duplicates=False)
            Z_Data['Y_close'] = Y_close
            Z_Data.to_csv('XXX_Data_checking.csv')
            return Z_Data

        elif Result_Type == 'Modeling_Result':
            count_Of_Match_out_of_total, std = self._make_prediction_on_dataframe_nn(Prediction_for='Model')
            return count_Of_Match_out_of_total, std

        if Result_Type == 'Prediction_Result':
            count_Of_Match_out_of_total, std = self._make_prediction_on_dataframe_nn(Prediction_for='Actual')
            return count_Of_Match_out_of_total, std

    #&___________________________________________________________________________________________________________
    def _further_data_extention_for_signal_management2(self, data, Required):
            point = mt5.symbol_info(self.symbol).point

            data['Pre_'+Required+'_to_Act_'+Required] = (data['Act_Pre_'+Required] - data['Act_'+Required]) / point
            data['Pre_'+Required+'_to_Pred_'+Required] = (data['Act_Pre_'+Required] - data['Pred_'+Required]) / point

            Avg_Min_Max = round(sts.stdev(data['Pre_'+Required+'_to_Pred_'+Required]), -1)
            data['entry_point'] = np.where(data['Pre_'+Required+'_to_Pred_'+Required] > Avg_Min_Max, data['Pre_'+Required+'_to_Pred_'+Required], np.where(data['Pre_'+Required+'_to_Pred_'+Required] < (-Avg_Min_Max), data['Pre_'+Required+'_to_Pred_'+Required], 0))
            data['profit_checking'] = np.where((data['Signal_0'] == "buy") & (data['entry_point'] < 0), -data['entry_point'], np.where((data['Signal_0'] == "sell") & (data['entry_point'] > 0), data['entry_point'], 0))
            data['Act_profit'] = np.where(data['profit_checking'] > 0, Avg_Min_Max/100, 0)
            data['CUMSUM_Act_pro'] = data['Act_profit'].cumsum()
            
            data['Points_Tp_Sl'] = Avg_Min_Max
            data['Signal_1'] = np.where(data['Act_profit'] > 0, data['Signal_0'], None)

            data['chg_Pred_'+Required] = data['Pred_'+Required] - data['Pred_'+Required].shift(1)
            data['chg_Act_'+Required] = data['Act_'+Required] - data['Act_'+Required].shift(1)
            data['std_Act_chg'] = data['chg_Act_'+Required].std()
            data['Match_of_chg'] = np.where(np.where(data['Pred_'+Required].shift(1) < data['Pred_'+Required].shift(0), "buy", "sell") == np.where(data['Act_'+Required].shift(1) < data['Act_'+Required].shift(0), "buy", "sell"), "Matched", "Not_Matched")
            data['Dif_Pred_chg_2_std'] = np.where(abs(data['chg_Pred_'+Required]) > data['chg_Pred_'+Required].std(), data['chg_Pred_'+Required], 0)
            data['Dif_Act_chg_2_std'] = np.where(abs(data['chg_Act_'+Required]) > data['chg_Act_'+Required].std(), data['chg_Act_'+Required], 0)
            data['Signal_2'] = np.where(data['Dif_Pred_chg_2_std'] > 0, 'buy', np.where(data['Dif_Pred_chg_2_std'] < 0, 'sell', None))
            data['TP_Value'] = np.where(data['Signal_2'] == 'sell', data['Act_'+Required].shift(1) - data['chg_Act_'+Required].std(), np.where(data['Signal_2'] == 'buy', data['Act_'+Required].shift(1) + data['chg_Act_'+Required].std(), None))
            data['SL_Value'] = np.where(data['Signal_2'] == 'sell', data['Act_'+Required].shift(1) + data['chg_Act_'+Required].std(), np.where(data['Signal_2'] == 'buy', data['Act_'+Required].shift(1) - data['chg_Act_'+Required].std(), None))
            data['Dif_2_tp'] = np.where((data['Signal_2'] == 'buy') & (data['Pred_'+Required] > data['TP_Value']), data['Pred_'+Required] - data['TP_Value'], np.where((data['Signal_2'] == 'sell') & (data['Pred_'+Required] < data['TP_Value']), data['TP_Value'] - data['Pred_'+Required], 0))
            data['Dif_2_sl'] = np.where((data['Signal_2'] == 'buy') & (data['Pred_'+Required] < data['SL_Value']), data['Pred_'+Required] - data['SL_Value'], np.where((data['Signal_2'] == 'sell') & (data['Pred_'+Required] > data['SL_Value']), data['SL_Value'] - data['Pred_'+Required], 0))
            data['Points_Tp_Sl'] = data[['Dif_2_tp', 'Dif_2_sl']].max(axis=1)

            data['Signal_3'] = np.where(data['Signal_2'] != None, data['Signal_2'], data['Signal_1'])
            data['Signal_4'] = np.where(data['Signal_3'].shift(1) != data['Signal_3'].shift(0), data['Signal_3'], None)
            data['Signal_5'] = np.where(data['Signal_4'] != None, data['Signal_4'], data['Signal_0'])
            data['chg_of_entry'] = data['Signal_5'] != data['Signal_5'].shift(1)
            data['points_of_sl_tp'] = np.where(data['chg_of_entry'] == True, Avg_Min_Max, 0)
            data['TP'] = np.where(data['Signal_5'] == 'sell', data['Pred_'+Required] - data['points_of_sl_tp'], np.where(data['Signal_5'] == 'buy', data['Pred_'+Required] + data['points_of_sl_tp'], None))
            data['SL'] = np.where(data['Signal_5'] == 'sell', data['Pred_'+Required] + data['points_of_sl_tp'], np.where(data['Signal_5'] == 'buy', data['Pred_'+Required] - data['points_of_sl_tp'], None))
            data['Signal_6'] = np.where((data['Signal_5'] == 'buy') & (data['Pred_'+Required] > data['TP']), 'TP', np.where((data['Signal_5'] == 'sell') & (data['Pred_'+Required] < data['TP']), 'TP', np.where((data['Signal_5'] == 'buy') & (data['Pred_'+Required] < data['SL']), 'SL', np.where((data['Signal_5'] == 'sell') & (data['Pred_'+Required] > data['SL']), 'SL', None))))
            data['Signal_7'] = np.where(data['Signal_6'] != None, data['Signal_6'], data['Signal_5'])
            data['chg_of_entry'] = data['Signal_7'] != data['Signal_7'].shift(1)
            data['points_of_sl_tp'] = np.where(data['chg_of_entry'] == True, Avg_Min_Max, 0)
            data['TP'] = np.where(data['Signal_7'] == 'sell', data['Pred_'+Required] - data['points_of_sl_tp'], np.where(data['Signal_7'] == 'buy', data['Pred_'+Required] + data['points_of_sl_tp'], None))
            data['SL'] = np.where(data['Signal_7'] == 'sell', data['Pred_'+Required] + data['points_of_sl_tp'], np.where(data['Signal_7'] == 'buy', data['Pred_'+Required] - data['points_of_sl_tp'], None))
            data['chg_of_entry'] = data['Signal_7'] != data['Signal_7'].shift(1)
            data['points_of_sl_tp'] = np.where(data['chg_of_entry'] == True, Avg_Min_Max, 0)
            data['TP'] = np.where(data['Signal_7'] == 'sell', data['Pred_'+Required] - data['points_of_sl_tp'], np.where(data['Signal_7'] == 'buy', data['Pred_'+Required] + data['points_of_sl_tp'], None))
            data['SL'] = np.where(data['Signal_7'] == 'sell', data['Pred_'+Required] + data['points_of_sl_tp'], np.where(data['Signal_7'] == 'buy', data['Pred_'+Required] - data['points_of_sl_tp'], None))
            data['chg_of_entry'] = data['Signal_7'] != data['Signal_7'].shift(1)
            data['points_of_sl_tp'] = np.where(data['chg_of_entry'] == True, Avg_Min_Max, 0)
            data['TP'] = np.where(data['Signal_7'] == 'sell', data['Pred_'+Required] - data['points_of_sl_tp'], np.where(data['Signal_7'] == 'buy', data['Pred_'+Required] + data['points_of_sl_tp'], None))
            data['SL'] = np.where(data['Signal_7'] == 'sell', data['Pred_'+Required] + data['points_of_sl_tp'], np.where(data['Signal_7'] == 'buy', data['Pred_'+Required] - data['points_of_sl_tp'], None))
            data['TP'] = np.where(data['Signal_7'] == None, None, data['TP'])
            data['SL'] = np.where(data['Signal_7'] == None, None, data['SL'])

            return data
#*_________________________________________________________________________________________________________________________________________________
class LotSizeCalculator:
    def __init__(self, symbol):
        self.symbol = symbol
        self.lot_size_sell = Order_Details(symbol).Sum_Symbol_SELL_Vol
        self.lot_size_buy = Order_Details(symbol).Sum_Symbol_BUY_Vol
        self.additional_lots = 0.01
        self.lot_factor_start = 0.000005
        self.lot_factor_stop = 2

    def calculate_lot_size(self, number=2):
        if number == 1:
            return 0.01
        elif number == 2:
            return round(MetaTraderHelper.get_account_balance() * self.lot_factor_start, 2)
        elif number == 3:
            return round(self.lot_size_buy * 2, 2)
        elif number == 4:
            return round(self.lot_size_sell * 2, 2)
        elif number == 5 or number == 6:
            return self.lot_size_sell + self.lot_size_buy + self.additional_lots
        elif number == 7:
            return self.lot_size_sell - self.lot_size_buy
        elif number == 8:
            return self.lot_size_buy - self.lot_size_sell
        elif number == 9:
            return (self.lot_size_sell * self.lot_factor_stop) - self.lot_size_buy + self.additional_lots
        elif number == 10:
            return (self.lot_size_buy * self.lot_factor_stop) - self.lot_size_sell + self.additional_lots
        else:
            return 0
        
    def stop_gap(self):
        gap_mapping = {
            "AUDCAD": 3,        "AUDCHF": 3,        "AUDJPY": 3,        "AUDNZD": 3,        "AUDUSD": 3,        "CADCHF": 3,        "CADJPY": 3,        "CHFJPY": 3,
            "EURAUD": 4,        "EURCAD": 4,        "EURCHF": 4,        "EURGBP": 4,        "EURJPY": 4,        "EURNZD": 3,        "EURUSD": 3,        "GBPAUD": 4,
            "GBPCAD": 2,        "GBPCHF": 3,        "GBPJPY": 3,        "GBPNZD": 3,        "GBPUSD": 4,        "NZDCAD": 2,        "NZDCHF": 2,        "NZDJPY": 2,
            "NZDUSD": 3,        "USDCAD": 3,        "USDCHF": 3,        "USDJPY": 3
        }    
        return gap_mapping.get(self.symbol, 0)        
#*_________________________________________________________________________________________________________________________________________________
class MetaTraderHelper:
    def __init__(self):
        mt5.initialize()

    def login(self, terminal):
        if terminal == 'ICMarcket-Demo':    
            login, password, server = 51227504, 'Lfwh37s4','ICMarketsSC-Demo'
        elif terminal == 'Exness-Demo':    
            login, password, server = 84672810, "DarkCode1991", "Exness-MT5Trial"
        elif terminal == 'MetaQuote_Demo':
            login, password, server = 5000602474, "dhyx5ehn", "MetaQuotes-Demo"
        elif terminal == 'OctaFX-Demo':    
            login, password, server = 88610505, "TaRyZypy", "OctaFX-Demo"
        else:
            raise ValueError("Invalid terminal specified.")
        
        return mt5.login(login, password, server)

    def get_initial_symbol_data(self, file):
        symbols = mt5.symbols_get()
        data_symbols = pd.DataFrame(symbols, columns=['custom', 'chart_mode', 'select', 'visible', 'session_deals', 'session_buy_orders', 'session_sell_orders', 'volume',
                                                      'volumehigh', 'volumelow', 'time', 'digits', 'spread', 'spread_float', 'ticks_bookdepth', 'trade_calc_mode', 'trade_mode', 'start_time', 'expiration_time',
                                                      'trade_stops_level', 'trade_freeze_level', 'trade_exemode', 'swap_mode', 'swap_rollover3days', 'margin_hedged_use_leg', 'expiration_mode', 'filling_mode',
                                                      'order_mode', 'order_gtc_mode', 'option_mode', 'option_right', 'bid', 'bidhigh', 'bidlow', 'ask', 'askhigh', 'asklow', 'last', 'lasthigh', 'lastlow', 'volume_real',
                                                      'volumehigh_real', 'volumelow_real', 'option_strike', 'point', 'trade_tick_value', 'trade_tick_value_profit', 'trade_tick_value_loss', 'trade_tick_size',
                                                      'trade_contract_size', 'trade_accrued_interest', 'trade_face_value', 'trade_liquidity_rate', 'volume_min', 'volume_max', 'volume_step', 'volume_limit', 'swap_long', 'swap_short',
                                                      'margin_initial', 'margin_maintenance', 'session_volume', 'session_turnover', 'session_interest', 'session_buy_orders_volume', 'session_sell_orders_volume',
                                                      'session_open', 'session_close', 'session_aw', 'session_price_settlement', 'session_price_limit_min', 'session_price_limit_max', 'margin_hedged', 'price_change',
                                                      'price_volatility', 'price_theoretical', 'price_greeks_delta', 'price_greeks_theta', 'price_greeks_gamma', 'price_greeks_vega', 'price_greeks_rho', 'price_greeks_omega',
                                                      'price_sensitivity', 'basis', 'category', 'currency_base', 'currency_profit', 'currency_margin', 'bank', 'description', 'exchange', 'formula', 'isin', 'name', 'page', 'path']
                              )
        data_symbols = data_symbols.rename_axis(index=None, columns=None)
        data_symbols.to_csv(file + '_Symbol_Details.csv', index=False)

    def get_list_of_symbols(self, file):
        data_symbols = pd.read_csv(file + '_Symbol_Details.csv')
        filtered_data = pd.DataFrame()
        filtered_data['name'] = data_symbols['name']
        filtered_data['spread'] = data_symbols['spread']
        filtered_data['digits'] = data_symbols['digits']
        filtered_data.to_csv(file + '_Symbols_List.csv', index=False)

    def get_active_orders_status(self):
        positions = mt5.positions_get()
        if positions == ():
            return None
        df = pd.DataFrame(list(positions), columns=positions[0]._asdict().keys())
        df['time'] = pd.to_datetime(df['time'], unit='s')
        df.drop(['time_update', 'time_msc', 'time_update_msc', 'external_id'], axis=1, inplace=True)
        return df

    def get_pending_orders_status(self):
        positions_pending = mt5.orders_get()
        if positions_pending == ():
            return None
        df = pd.DataFrame(list(positions_pending), columns=positions_pending[0]._asdict().keys())
        df['time_setup'] = pd.to_datetime(df['time_setup'], unit='s')
        df.drop(['time_setup_msc', 'time_done', 'time_done_msc', 'external_id'], axis=1, inplace=True)
        return df

    def get_data_info(self):
        total_profit = round(self.get_positions()['profit'].sum(), 2)
        positions_total = mt5.positions_total()

        positions_df = self.get_positions()

        min_profit = positions_df['profit'].min()
        min_profit_id = positions_df['profit'].idxmin()
        min_profit_ticket = int(positions_df['ticket'][min_profit_id])

        max_profit = positions_df['profit'].max()
        max_profit_id = positions_df['profit'].idxmax()
        max_profit_ticket = int(positions_df['ticket'][max_profit_id])

        return total_profit, positions_total, min_profit, min_profit_ticket, max_profit, max_profit_ticket

    def min_ticket_info(self, symbol):
        df = self.get_positions()
        if df is not None and not df.empty:
            ticket_num = df[df['symbol'] == symbol]['ticket'].min()
            order_index = df[df['ticket'] == ticket_num].index
            order_type = int(df['type'][order_index].to_string(index=False))
            return ticket_num, order_type
        else:
            return 0, 0
    
    def max_ticket_info(self, symbol):
        df = self.get_positions()
        if df is not None and not df.empty:
            ticket_num = df[df['symbol'] == symbol]['ticket'].max()
            order_index = df[df['ticket'] == ticket_num].index
            order_type = int(df['type'][order_index].to_string(index=False))
            return ticket_num, order_type
        else:
            return 0, 0

    def get_symbol_info(self, symbol):
        symbol_info = mt5.symbol_info(symbol)
        if symbol_info is None:
            print(f"Symbol '{symbol}' not found")
            return None
        return symbol_info
    
    def get_ask(self, symbol):
        symbol_info = self.get_symbol_info(symbol)
        if symbol_info is None:
            return None
        tick = mt5.symbol_info_tick(symbol)
        if tick is None:
            print(f"Failed to retrieve tick data for symbol: {symbol}")
            return None
        return tick.ask
    
    def get_bid(self, symbol):
        symbol_info = self.get_symbol_info(symbol)
        if symbol_info is None:
            return None
        tick = mt5.symbol_info_tick(symbol)
        if tick is None:
            print(f"Failed to retrieve tick data for symbol: {symbol}")
            return None
        return tick.bid
    
    def get_point(self, symbol):
        symbol_info = self.get_symbol_info(symbol)
        if symbol_info is None:
            return None
        return symbol_info.point
    
    def get_digits(self, symbol):
        symbol_info = self.get_symbol_info(symbol)
        if symbol_info is None:
            return None
        return symbol_info.digits
    
    def save_symbol_list_to_csv(self, filename):
        import csv
        if not mt5.initialize():
            print("Failed to initialize MetaTrader 5 connection")
            return
    
        symbols = mt5.symbols_get()
    
        with open(filename, mode='w', newline='') as file:
            writer = csv.writer(file)
            writer.writerow(['Symbol'])
            for symbol in symbols:
                writer.writerow([symbol.name])
    
        mt5.shutdown()
        print(f"Symbol list saved to {filename}")
    
    def Account_Info(self):
        import pandas as pd
        if not mt5.initialize():
            print("initialize() failed, error code =", mt5.last_error())
            return
    
        login, password, server = 51227504, 'Lfwh37s4', 'ICMarketsSC-Demo'
        authorized = mt5.login(login, password, server)
        if authorized:
            account_info = mt5.account_info()
            if account_info is not None:
                account_info_dict = account_info._asdict()
                df = pd.DataFrame(list(account_info_dict.items()), columns=['property', 'value'])
        else:
            print("failed to connect to trade account 25115284 with password=gqz0343lbdm, error code =", mt5.last_error())
    
        mt5.shutdown()
        return df
    
    def get_account_balance(self):
        if not mt5.initialize():
            return None
    
        account = mt5.account_info()
        balance = account.balance if account is not None else None
    
        mt5.shutdown()
        return balance

    def shutdown(self):
        mt5.shutdown()
#*_________________________________________________________________________________________________________________________________________________
class Order_Details:
    def __init__(self,symbol, ordar_position=0):
        try:
            self.point      = float(mt5.symbol_info(symbol).point)
        except Exception:
            self.point      = None

        self.All_Active = MetaTraderHelper.get_active_orders_status() #fm5.Terminal()
        try:
            self.Count_All_Active = len(self.All_Active.index)
        except Exception:
            self.Count_All_Active = 0

        self.Symbol_All_Active  = self.All_Active[self.All_Active['symbol'] == symbol]                                                                    if self.Count_All_Active > 0 else 0
        self.Symbol_All_BUY     = self.Symbol_All_Active[self.Symbol_All_Active['type'] == 0]                                                             if self.Count_All_Active > 0 else 0 
        self.Symbol_All_SELL    = self.Symbol_All_Active[self.Symbol_All_Active['type'] == 1]                                                             if self.Count_All_Active > 0 else 0 
        self.First_Order_Type   = self.Symbol_All_Active['type'].iloc[0]                                                                                  if self.Count_All_Active > 0 else 0

        self.Count_Symbol_All_Active  = int(self.Symbol_All_Active.count()['ticket'])                                                                   if self.Count_All_Active > 0 else 0
        self.Sum_Symbol_Active_Profit = int(self.Symbol_All_Active['profit'].sum())                                                                     if self.Count_All_Active > 0 else 0
        self.Last_Order_Type          = self.Symbol_All_Active['type'].iloc[self.Count_Symbol_All_Active-1]                                             if self.Count_All_Active > 0 else 0

        self.Count_Symbol_BUY         = int(self.Symbol_All_BUY.count()['ticket'])                                                                      if self.Count_All_Active > 0 else 0
        self.Count_Symbol_SELL        = int(self.Symbol_All_SELL.count()['ticket'])                                                                     if self.Count_All_Active > 0 else 0

        self.Sum_Symbol_BUY_Vol       = self.Symbol_All_BUY['volume'].sum()                                                                                 if self.Count_All_Active > 0 else 0
        self.Sum_Symbol_SELL_Vol      = self.Symbol_All_SELL['volume'].sum()                                                                                if self.Count_All_Active > 0 else 0

        self.Sum_Symbol_BUY_Profit    = self.Symbol_All_BUY['profit'].sum()                                                                                 if self.Count_All_Active > 0 else 0
        self.Sum_Symbol_SELL_Profit   = self.Symbol_All_SELL['profit'].sum()                                                                                if self.Count_All_Active > 0 else 0

        self.First_Symbol_BUY_Ticket  = self.Symbol_All_BUY['ticket'].min()                                                                               if self.Count_Symbol_BUY > 0 else 0
        self.First_Symbol_BUY_Price   = float(self.Symbol_All_BUY[self.Symbol_All_BUY['ticket'] == self.First_Symbol_BUY_Ticket]['price_open'])           if self.Count_Symbol_BUY > 0 else 0
        self.First_Symbol_BUY_TP      = float(self.Symbol_All_BUY[self.Symbol_All_BUY['ticket'] == self.First_Symbol_BUY_Ticket]['tp'])                   if self.Count_Symbol_BUY > 0 else 0
        self.First_Symbol_BUY_SL      = float(self.Symbol_All_BUY[self.Symbol_All_BUY['ticket'] == self.First_Symbol_BUY_Ticket]['sl'])                   if self.Count_Symbol_BUY > 0 else 0
        self.First_Symbol_BUY_Vol     = float(self.Symbol_All_BUY[self.Symbol_All_BUY['ticket'] == self.First_Symbol_BUY_Ticket]['volume'])               if self.Count_Symbol_BUY > 0 else 0
        self.First_Symbol_BUY_Profit  = float(self.Symbol_All_BUY[self.Symbol_All_BUY['ticket'] == self.First_Symbol_BUY_Ticket]['profit'])               if self.Count_Symbol_BUY > 0 else 0

        self.Required_Symbol_BUY_Ticket  = self.Symbol_All_BUY['ticket'].iloc[ordar_position]                                                             if self.Count_Symbol_BUY > 1 else 0
        self.Required_Symbol_BUY_Price   = float(self.Symbol_All_BUY[self.Symbol_All_BUY['ticket'] == self.Required_Symbol_BUY_Ticket]['price_open'])     if self.Count_Symbol_BUY > 1 else 0
        self.Required_Symbol_BUY_TP      = float(self.Symbol_All_BUY[self.Symbol_All_BUY['ticket'] == self.Required_Symbol_BUY_Ticket]['tp'])             if self.Count_Symbol_BUY > 1 else 0
        self.Required_Symbol_BUY_SL      = float(self.Symbol_All_BUY[self.Symbol_All_BUY['ticket'] == self.Required_Symbol_BUY_Ticket]['sl'])             if self.Count_Symbol_BUY > 1 else 0
        self.Required_Symbol_BUY_Vol     = float(self.Symbol_All_BUY[self.Symbol_All_BUY['ticket'] == self.Required_Symbol_BUY_Ticket]['volume'])         if self.Count_Symbol_BUY > 1 else 0
        self.Required_Symbol_BUY_Profit  = float(self.Symbol_All_BUY[self.Symbol_All_BUY['ticket'] == self.Required_Symbol_BUY_Ticket]['profit'])         if self.Count_Symbol_BUY > 1 else 0

        self.Last_Symbol_BUY_Ticket  = self.Symbol_All_BUY['ticket'].max()                                                                                if self.Count_Symbol_BUY > 1 else 0
        self.Last_Symbol_BUY_Price   = float(self.Symbol_All_BUY[self.Symbol_All_BUY['ticket'] == self.Last_Symbol_BUY_Ticket]['price_open'])             if self.Count_Symbol_BUY > 1 else 0
        self.Last_Symbol_BUY_TP      = float(self.Symbol_All_BUY[self.Symbol_All_BUY['ticket'] == self.Last_Symbol_BUY_Ticket]['tp'])                     if self.Count_Symbol_BUY > 1 else 0
        self.Last_Symbol_BUY_SL      = float(self.Symbol_All_BUY[self.Symbol_All_BUY['ticket'] == self.Last_Symbol_BUY_Ticket]['sl'])                     if self.Count_Symbol_BUY > 1 else 0
        self.Last_Symbol_BUY_Vol     = float(self.Symbol_All_BUY[self.Symbol_All_BUY['ticket'] == self.Last_Symbol_BUY_Ticket]['volume'])                 if self.Count_Symbol_BUY > 1 else 0
        self.Last_Symbol_BUY_Profit  = float(self.Symbol_All_BUY[self.Symbol_All_BUY['ticket'] == self.Last_Symbol_BUY_Ticket]['profit'])                 if self.Count_Symbol_BUY > 1 else 0

        self.First_Symbol_SELL_Ticket  = self.Symbol_All_SELL['ticket'].min()                                                                             if self.Count_Symbol_SELL > 0 else 0
        self.First_Symbol_SELL_Price   = float(self.Symbol_All_SELL[self.Symbol_All_SELL['ticket'] == self.First_Symbol_SELL_Ticket]['price_open'])       if self.Count_Symbol_SELL > 0 else 0
        self.First_Symbol_SELL_TP      = float(self.Symbol_All_SELL[self.Symbol_All_SELL['ticket'] == self.First_Symbol_SELL_Ticket]['tp'])               if self.Count_Symbol_SELL > 0 else 0
        self.First_Symbol_SELL_SL      = float(self.Symbol_All_SELL[self.Symbol_All_SELL['ticket'] == self.First_Symbol_SELL_Ticket]['sl'])               if self.Count_Symbol_SELL > 0 else 0
        self.First_Symbol_SELL_Vol     = float(self.Symbol_All_SELL[self.Symbol_All_SELL['ticket'] == self.First_Symbol_SELL_Ticket]['volume'])           if self.Count_Symbol_SELL > 0 else 0
        self.First_Symbol_SELL_Profit  = float(self.Symbol_All_SELL[self.Symbol_All_SELL['ticket'] == self.First_Symbol_SELL_Ticket]['profit'])           if self.Count_Symbol_SELL > 0 else 0

        self.Required_Symbol_SELL_Ticket  = self.Symbol_All_SELL['ticket'].iloc[ordar_position]                                                           if self.Count_Symbol_SELL > 1 else 0
        self.Required_Symbol_SELL_Price   = float(self.Symbol_All_SELL[self.Symbol_All_SELL['ticket'] == self.Required_Symbol_SELL_Ticket]['price_open']) if self.Count_Symbol_SELL > 1 else 0
        self.Required_Symbol_SELL_TP      = float(self.Symbol_All_SELL[self.Symbol_All_SELL['ticket'] == self.Required_Symbol_SELL_Ticket]['tp'])         if self.Count_Symbol_SELL > 1 else 0
        self.Required_Symbol_SELL_SL      = float(self.Symbol_All_SELL[self.Symbol_All_SELL['ticket'] == self.Required_Symbol_SELL_Ticket]['sl'])         if self.Count_Symbol_SELL > 1 else 0
        self.Required_Symbol_SELL_Vol     = float(self.Symbol_All_SELL[self.Symbol_All_SELL['ticket'] == self.Required_Symbol_SELL_Ticket]['volume'])     if self.Count_Symbol_SELL > 1 else 0
        self.Required_Symbol_SELL_Profit  = float(self.Symbol_All_SELL[self.Symbol_All_SELL['ticket'] == self.Required_Symbol_SELL_Ticket]['profit'])     if self.Count_Symbol_SELL > 1 else 0

        self.Last_Symbol_SELL_Ticket  = self.Symbol_All_SELL['ticket'].max()                                                                              if self.Count_Symbol_SELL > 1 else 0
        self.Last_Symbol_SELL_Price   = float(self.Symbol_All_SELL[self.Symbol_All_SELL['ticket'] == self.Last_Symbol_SELL_Ticket]['price_open'])         if self.Count_Symbol_SELL > 1 else 0
        self.Last_Symbol_SELL_TP      = float(self.Symbol_All_SELL[self.Symbol_All_SELL['ticket'] == self.Last_Symbol_SELL_Ticket]['tp'])                 if self.Count_Symbol_SELL > 1 else 0
        self.Last_Symbol_SELL_SL      = float(self.Symbol_All_SELL[self.Symbol_All_SELL['ticket'] == self.Last_Symbol_SELL_Ticket]['sl'])                 if self.Count_Symbol_SELL > 1 else 0
        self.Last_Symbol_SELL_Vol     = float(self.Symbol_All_SELL[self.Symbol_All_SELL['ticket'] == self.Last_Symbol_SELL_Ticket]['volume'])             if self.Count_Symbol_SELL > 1 else 0
        self.Last_Symbol_SELL_Profit  = float(self.Symbol_All_SELL[self.Symbol_All_SELL['ticket'] == self.Last_Symbol_SELL_Ticket]['profit'])             if self.Count_Symbol_SELL > 1 else 0

        self.Dif_First_BUY_Price_TP = abs(self.First_Symbol_BUY_Price    - self.First_Symbol_BUY_TP)                                                if self.Count_Symbol_BUY > 1 else 0
        self.Dif_Last_BUY_Price_TP  = abs(self.Last_Symbol_BUY_Price     - self.Last_Symbol_BUY_TP)                                                 if self.Count_Symbol_BUY > 1 else 0  
        self.Dif_First_BUY_Price_SL = abs(self.First_Symbol_BUY_Price    - self.First_Symbol_BUY_SL)                                                if self.Count_Symbol_BUY > 1 else 0  
        self.Dif_Last_BUY_Price_SL  = abs(self.Last_Symbol_BUY_Price     - self.Last_Symbol_BUY_SL)                                                 if self.Count_Symbol_BUY > 1 else 0  

        self.Dif_First_SELL_Price_TP = abs(self.First_Symbol_SELL_Price  - self.First_Symbol_SELL_TP)                                               if self.Count_Symbol_SELL > 1 else 0
        self.Dif_Last_SELL_Price_TP  = abs(self.Last_Symbol_SELL_Price   - self.Last_Symbol_SELL_TP)                                                if self.Count_Symbol_SELL > 1 else 0
        self.Dif_First_SELL_Price_SL = abs(self.First_Symbol_SELL_Price  - self.First_Symbol_SELL_SL)                                               if self.Count_Symbol_SELL > 1 else 0
        self.Dif_Last_SELL_Price_SL  = abs(self.Last_Symbol_SELL_Price   - self.Last_Symbol_SELL_SL)                                                if self.Count_Symbol_SELL > 1 else 0

        self.Dif_First_BUY_Price_Second_BUY_Price   = abs(self.First_Symbol_BUY_Price   - self.Required_Symbol_BUY_Price)                           if self.Count_Symbol_BUY > 1 else 0  
        self.Dif_First_SELL_Price_Second_SELL_Price = abs(self.First_Symbol_SELL_Price  - self.Required_Symbol_SELL_Price)                          if self.Count_Symbol_SELL > 1 else 0  

        self.Dif_First_BUY_Price_Last_BUY_Price     = abs(self.First_Symbol_BUY_Price   - self.Last_Symbol_BUY_Price)                                 if self.Count_Symbol_BUY > 1 else 0
        self.Dif_First_SELL_Price_Last_SELL_Price   = abs(self.First_Symbol_SELL_Price  - self.Last_Symbol_SELL_Price)                                if self.Count_Symbol_SELL > 1 else 0

        self.Dif_First_BUY_Price_First_SELL_Price   = abs(self.First_Symbol_BUY_Price  - self.First_Symbol_SELL_Price)                              if self.Count_All_Active > 0 else 0

        #*=========================================================================
        #*================================================== Pending Order Atribute
        #*=========================================================================
        self.All_Pending = MetaTraderHelper.get_pending_orders_status() #fm5.Pending_Terminal()
        try:
            self.Count_All_Pending = len(self.All_Pending.index)
        except Exception:
            self.Count_All_Pending = 0

        # self.Count_All_Pending =  self.All_Pending.count()
        self.Symbol_All_Pending = self.All_Pending[self.All_Pending['symbol'] == symbol]                                                                  if self.Count_All_Pending > 0 else 0


        self.Symbol_All_BUYLIMIT     = self.Symbol_All_Pending[self.Symbol_All_Pending['type'] == 2]                                                      if self.Count_All_Pending > 0 else 0
        self.Symbol_All_SELLLIMIT    = self.Symbol_All_Pending[self.Symbol_All_Pending['type'] == 3]                                                      if self.Count_All_Pending > 0 else 0
        self.Symbol_All_BUYSTOP      = self.Symbol_All_Pending[self.Symbol_All_Pending['type'] == 4]                                                      if self.Count_All_Pending > 0 else 0
        self.Symbol_All_SELLSTOP     = self.Symbol_All_Pending[self.Symbol_All_Pending['type'] == 5]                                                      if self.Count_All_Pending > 0 else 0

        self.Count_Symbol_BUYLIMIT   = self.Symbol_All_BUYLIMIT['ticket'].count()                                                                         if self.Count_All_Pending > 0 else 0
        self.Count_Symbol_SELLLIMIT  = self.Symbol_All_SELLLIMIT['ticket'].count()                                                                        if self.Count_All_Pending > 0 else 0
        self.Count_Symbol_BUYSTOP    = self.Symbol_All_BUYSTOP['ticket'].count()                                                                          if self.Count_All_Pending > 0 else 0
        self.Count_Symbol_SELLSTOP   = self.Symbol_All_SELLSTOP['ticket'].count()                                                                         if self.Count_All_Pending > 0 else 0
        self.Count_Symbol_All_Pending = self.Count_Symbol_BUYLIMIT + self.Count_Symbol_SELLLIMIT + self.Count_Symbol_BUYSTOP + self.Count_Symbol_SELLSTOP  if self.Count_All_Pending > 0 else 0

        self.First_Symbol_BUYLIMIT_Ticket  = self.Symbol_All_BUYLIMIT['ticket'].min()                                                                                               if self.Count_Symbol_BUYLIMIT > 0 else 0
        self.First_Symbol_BUYLIMIT_Price  = float(self.Symbol_All_BUYLIMIT[self.Symbol_All_BUYLIMIT['ticket']   == self.First_Symbol_BUYLIMIT_Ticket]['price_open'].item())         if self.Count_Symbol_BUYLIMIT > 0 else 0
        self.First_Symbol_BUYLIMIT_TP     = float(self.Symbol_All_BUYLIMIT[self.Symbol_All_BUYLIMIT['ticket']   == self.First_Symbol_BUYLIMIT_Ticket]['tp'].item())                 if self.Count_Symbol_BUYLIMIT > 0 else 0
        self.First_Symbol_BUYLIMIT_SL     = float(self.Symbol_All_BUYLIMIT[self.Symbol_All_BUYLIMIT['ticket']   == self.First_Symbol_BUYLIMIT_Ticket]['sl'].item())                 if self.Count_Symbol_BUYLIMIT > 0 else 0
        self.First_Symbol_BUYLIMIT_Vol    = float(self.Symbol_All_BUYLIMIT[self.Symbol_All_BUYLIMIT['ticket']   == self.First_Symbol_BUYLIMIT_Ticket]['volume_current'].item())     if self.Count_Symbol_BUYLIMIT > 0 else 0

        self.First_Symbol_SELLLIMIT_Ticket = self.Symbol_All_SELLLIMIT['ticket'].min()                                                                                              if self.Count_Symbol_SELLLIMIT > 0 else 0
        self.First_Symbol_SELLLIMIT_Price = float(self.Symbol_All_SELLLIMIT[self.Symbol_All_SELLLIMIT['ticket'] == self.First_Symbol_SELLLIMIT_Ticket]['price_open'].item())        if self.Count_Symbol_SELLLIMIT > 0 else 0
        self.First_Symbol_SELLLIMIT_TP    = float(self.Symbol_All_SELLLIMIT[self.Symbol_All_SELLLIMIT['ticket'] == self.First_Symbol_SELLLIMIT_Ticket]['tp'].item())                if self.Count_Symbol_SELLLIMIT > 0 else 0
        self.First_Symbol_SELLLIMIT_SL    = float(self.Symbol_All_SELLLIMIT[self.Symbol_All_SELLLIMIT['ticket'] == self.First_Symbol_SELLLIMIT_Ticket]['sl'].item())                if self.Count_Symbol_SELLLIMIT > 0 else 0
        self.First_Symbol_SELLLIMIT_Vol   = float(self.Symbol_All_SELLLIMIT[self.Symbol_All_SELLLIMIT['ticket'] == self.First_Symbol_SELLLIMIT_Ticket]['volume_current'].item())    if self.Count_Symbol_SELLLIMIT > 0 else 0

        self.First_Symbol_BUYSTOP_Ticket   = self.Symbol_All_BUYSTOP['ticket'].min()                                                                                                if self.Count_Symbol_BUYSTOP > 0 else 0
        self.First_Symbol_BUYSTOP_Price   = float(self.Symbol_All_BUYSTOP[self.Symbol_All_BUYSTOP['ticket']     == self.First_Symbol_BUYSTOP_Ticket]['price_open'].item())          if self.Count_Symbol_BUYSTOP > 0 else 0
        self.First_Symbol_BUYSTOP_TP      = float(self.Symbol_All_BUYSTOP[self.Symbol_All_BUYSTOP['ticket']     == self.First_Symbol_BUYSTOP_Ticket]['tp'].item())                  if self.Count_Symbol_BUYSTOP > 0 else 0
        self.First_Symbol_BUYSTOP_SL      = float(self.Symbol_All_BUYSTOP[self.Symbol_All_BUYSTOP['ticket']     == self.First_Symbol_BUYSTOP_Ticket]['sl'].item())                  if self.Count_Symbol_BUYSTOP > 0 else 0
        self.First_Symbol_BUYSTOP_Vol     = float(self.Symbol_All_BUYSTOP[self.Symbol_All_BUYSTOP['ticket']     == self.First_Symbol_BUYSTOP_Ticket]['volume_current'].item())      if self.Count_Symbol_BUYSTOP > 0 else 0

        self.First_Symbol_SELLSTOP_Ticket  = self.Symbol_All_SELLSTOP['ticket'].min()                                                                                               if self.Count_Symbol_SELLSTOP > 0 else 0
        self.First_Symbol_SELLSTOP_Price  = float(self.Symbol_All_SELLSTOP[self.Symbol_All_SELLSTOP['ticket']   == self.First_Symbol_SELLSTOP_Ticket]['price_open'].item())         if self.Count_Symbol_SELLSTOP > 0 else 0
        self.First_Symbol_SELLSTOP_TP     = float(self.Symbol_All_SELLSTOP[self.Symbol_All_SELLSTOP['ticket']   == self.First_Symbol_SELLSTOP_Ticket]['tp'].item())                 if self.Count_Symbol_SELLSTOP > 0 else 0
        self.First_Symbol_SELLSTOP_SL     = float(self.Symbol_All_SELLSTOP[self.Symbol_All_SELLSTOP['ticket']   == self.First_Symbol_SELLSTOP_Ticket]['sl'].item())                 if self.Count_Symbol_SELLSTOP > 0 else 0
        self.First_Symbol_SELLSTOP_Vol    = float(self.Symbol_All_SELLSTOP[self.Symbol_All_SELLSTOP['ticket']   == self.First_Symbol_SELLSTOP_Ticket]['volume_current'].item())     if self.Count_Symbol_SELLSTOP > 0 else 0

        self.Last_Symbol_BUYLIMIT_Ticket  = self.Symbol_All_BUYLIMIT['ticket'].max()                                                                                                if self.Count_Symbol_BUYLIMIT > 1 else 0        
        self.Last_Symbol_BUYLIMIT_Price   = float(self.Symbol_All_BUYLIMIT[self.Symbol_All_BUYLIMIT['ticket']   == self.Last_Symbol_BUYLIMIT_Ticket]['price_open'].item())          if self.Count_Symbol_BUYLIMIT > 1 else 0
        self.Last_Symbol_BUYLIMIT_TP      = float(self.Symbol_All_BUYLIMIT[self.Symbol_All_BUYLIMIT['ticket']   == self.Last_Symbol_BUYLIMIT_Ticket]['tp'].item())                  if self.Count_Symbol_BUYLIMIT > 1 else 0
        self.Last_Symbol_BUYLIMIT_SL      = float(self.Symbol_All_BUYLIMIT[self.Symbol_All_BUYLIMIT['ticket']   == self.Last_Symbol_BUYLIMIT_Ticket]['sl'].item())                  if self.Count_Symbol_BUYLIMIT > 1 else 0
        self.Last_Symbol_BUYLIMIT_Vol     = float(self.Symbol_All_BUYLIMIT[self.Symbol_All_BUYLIMIT['ticket']   == self.Last_Symbol_BUYLIMIT_Ticket]['volume_current'].item())      if self.Count_Symbol_BUYLIMIT > 1 else 0

        self.Last_Symbol_SELLLIMIT_Ticket  = self.Symbol_All_SELLLIMIT['ticket'].max()                                                                                              if self.Count_Symbol_SELLLIMIT > 1 else 0
        self.Last_Symbol_SELLLIMIT_Price  = float(self.Symbol_All_SELLLIMIT[self.Symbol_All_SELLLIMIT['ticket'] == self.Last_Symbol_SELLLIMIT_Ticket]['price_open'].item())         if self.Count_Symbol_SELLLIMIT > 1 else 0
        self.Last_Symbol_SELLLIMIT_TP     = float(self.Symbol_All_SELLLIMIT[self.Symbol_All_SELLLIMIT['ticket'] == self.Last_Symbol_SELLLIMIT_Ticket]['tp'].item())                 if self.Count_Symbol_SELLLIMIT > 1 else 0
        self.Last_Symbol_SELLLIMIT_SL     = float(self.Symbol_All_SELLLIMIT[self.Symbol_All_SELLLIMIT['ticket'] == self.Last_Symbol_SELLLIMIT_Ticket]['sl'].item())                 if self.Count_Symbol_SELLLIMIT > 1 else 0
        self.Last_Symbol_SELLLIMIT_Vol    = float(self.Symbol_All_SELLLIMIT[self.Symbol_All_SELLLIMIT['ticket'] == self.Last_Symbol_SELLLIMIT_Ticket]['volume_current'].item())     if self.Count_Symbol_SELLLIMIT > 1 else 0

        self.Last_Symbol_BUYSTOP_Ticket    = self.Symbol_All_BUYSTOP['ticket'].max()                                                                                                if self.Count_Symbol_BUYSTOP > 1 else 0    
        self.Last_Symbol_BUYSTOP_Price    = float(self.Symbol_All_BUYSTOP[self.Symbol_All_BUYSTOP['ticket']     == self.Last_Symbol_BUYSTOP_Ticket]['price_open'].item())           if self.Count_Symbol_BUYSTOP > 1 else 0
        self.Last_Symbol_BUYSTOP_TP       = float(self.Symbol_All_BUYSTOP[self.Symbol_All_BUYSTOP['ticket']     == self.Last_Symbol_BUYSTOP_Ticket]['tp'].item())                   if self.Count_Symbol_BUYSTOP > 1 else 0
        self.Last_Symbol_BUYSTOP_SL       = float(self.Symbol_All_BUYSTOP[self.Symbol_All_BUYSTOP['ticket']     == self.Last_Symbol_BUYSTOP_Ticket]['sl'].item())                   if self.Count_Symbol_BUYSTOP > 1 else 0
        self.Last_Symbol_BUYSTOP_Vol      = float(self.Symbol_All_BUYSTOP[self.Symbol_All_BUYSTOP['ticket']     == self.Last_Symbol_BUYSTOP_Ticket]['volume_current'].item())       if self.Count_Symbol_BUYSTOP > 1 else 0

        self.Last_Symbol_SELLSTOP_Ticket   = self.Symbol_All_SELLSTOP['ticket'].max()                                                                                               if self.Count_Symbol_SELLSTOP > 1 else 0
        self.Last_Symbol_SELLSTOP_Price   = float(self.Symbol_All_SELLSTOP[self.Symbol_All_SELLSTOP['ticket']   == self.Last_Symbol_SELLSTOP_Ticket]['price_open'].item())          if self.Count_Symbol_SELLSTOP > 1 else 0
        self.Last_Symbol_SELLSTOP_TP      = float(self.Symbol_All_SELLSTOP[self.Symbol_All_SELLSTOP['ticket']   == self.Last_Symbol_SELLSTOP_Ticket]['tp'].item())                  if self.Count_Symbol_SELLSTOP > 1 else 0
        self.Last_Symbol_SELLSTOP_SL      = float(self.Symbol_All_SELLSTOP[self.Symbol_All_SELLSTOP['ticket']   == self.Last_Symbol_SELLSTOP_Ticket]['sl'].item())                  if self.Count_Symbol_SELLSTOP > 1 else 0
        self.Last_Symbol_SELLSTOP_Vol     = float(self.Symbol_All_SELLSTOP[self.Symbol_All_SELLSTOP['ticket']   == self.Last_Symbol_SELLSTOP_Ticket]['volume_current'].item())      if self.Count_Symbol_SELLSTOP > 1 else 0

        self.Sum_Symbol_BUYLIMIT_Vol      = float(self.Symbol_All_BUYLIMIT['volume_current'].sum())                                                                                 if self.Count_Symbol_BUYLIMIT > 0 else 0
        self.Sum_Symbol_SELLLIMIT_Vol     = float(self.Symbol_All_SELLLIMIT['volume_current'].sum())                                                                                if self.Count_Symbol_SELLLIMIT > 0 else 0
        self.Sum_Symbol_BUYSTOP_Vol       = float(self.Symbol_All_BUYSTOP['volume_current'].sum())                                                                                  if self.Count_Symbol_BUYSTOP > 0 else 0
        self.Sum_Symbol_SELLSTOP_Vol      = float(self.Symbol_All_SELLSTOP['volume_current'].sum())                                                                                 if self.Count_Symbol_SELLSTOP > 0 else 0

        self.Sum_Symbol_Pending_Vol       = round(float(self.Sum_Symbol_BUYLIMIT_Vol+self.Sum_Symbol_SELLLIMIT_Vol+self.Sum_Symbol_BUYSTOP_Vol+self.Sum_Symbol_SELLSTOP_Vol),3)
#*_________________________________________________________________________________________________________________________________________________
class OrderManager:
    def __init__(self):
        self.DEVIATION = 20
        self.order_dict = {
            'BUY': mt5.ORDER_TYPE_BUY,
            'SELL': mt5.ORDER_TYPE_SELL,
            'BUYLIMIT': mt5.ORDER_TYPE_BUY_LIMIT,
            'SELLLIMIT': mt5.ORDER_TYPE_SELL_LIMIT,
            'BUYSTOP': mt5.ORDER_TYPE_BUY_STOP,
            'SELLSTOP': mt5.ORDER_TYPE_SELL_STOP
        }
        self.act_dict = {
            'BUY': mt5.TRADE_ACTION_DEAL,
            'SELL': mt5.TRADE_ACTION_DEAL,
            'BUYLIMIT': mt5.TRADE_ACTION_PENDING,
            'SELLLIMIT': mt5.TRADE_ACTION_PENDING,
            'BUYSTOP': mt5.TRADE_ACTION_PENDING,
            'SELLSTOP': mt5.TRADE_ACTION_PENDING
        }
        self.magic_dict = {
            'BUY': 0, 'SELL': 1,
            'BUYLIMIT': 2, 'SELLLIMIT': 3,
            'BUYSTOP': 4, 'SELLSTOP': 5
        }

    def market_order(self, symbol, volume, order_type, sl_, tp_, pred_type, pending_price=0):
        price_dict = {
            'BUY': float(mt5.symbol_info_tick(symbol).ask),
            'SELL': float(mt5.symbol_info_tick(symbol).bid),
            'BUYLIMIT': pending_price,
            'SELLLIMIT': pending_price,
            'BUYSTOP': pending_price,
            'SELLSTOP': pending_price
        }

        request = {
            "action": self.act_dict[order_type],
            "symbol": symbol,
            "volume": volume,
            "type": self.order_dict[order_type],
            "price": price_dict[order_type],
            "sl": sl_,
            "tp": tp_,
            "deviation": self.DEVIATION,
            "magic": int(hashlib.sha1(symbol.encode("utf-8")).hexdigest(), 16) % (10 ** 10) + self.magic_dict[
                order_type],
            "comment": f"{symbol}-F{pred_type}",
            "type_time": mt5.ORDER_TIME_GTC,
            "type_filling": mt5.ORDER_FILLING_IOC,
        }

        order_result = mt5.order_send(request)
        return order_result

    def close_order(self, ticket):
        positions = mt5.positions_get()

        for pos in positions:
            tick = mt5.symbol_info_tick(pos.symbol)

            type_dict = {0: 1, 1: 0}  # 0 represents buy, 1 represents sell - inverting order_type to close the position
            price_dict = {0: tick.ask, 1: tick.bid}

            if pos.ticket == ticket:
                request = {
                    "action": mt5.TRADE_ACTION_DEAL,
                    "position": pos.ticket,
                    "symbol": pos.symbol,
                    "volume": pos.volume,
                    "type": type_dict[pos.type],
                    "price": price_dict[pos.type],
                    "deviation": 20,
                    "magic": 100,
                    "comment": "python close order",
                    "type_time": mt5.ORDER_TIME_GTC,
                    "type_filling": mt5.ORDER_FILLING_IOC,
                }
                order_result = mt5.order_send(request)
                return order_result
        return 'Ticket does not exist'

    def remove_order(self, ticket_no):
        positions = mt5.orders_get()

        for pos in positions:
            if pos.ticket == int(ticket_no):
                request = {
                    "action": mt5.TRADE_ACTION_REMOVE,
                    "order": int(ticket_no)
                }
                order_result = mt5.order_send(request)
                return order_result

    def modify_pending_order(self, ticket_no, price, sl, tp):
        request = {
            "action": mt5.TRADE_ACTION_MODIFY,
            "order": int(ticket_no),
            "price": float(price),
            "sl": float(sl),
            "tp": float(tp)
        }
        return mt5.order_send(request)

    def modify_active_order(self, ticket_no, sl_, tp_):
        request = {
            "action": mt5.TRADE_ACTION_SLTP,
            "position": ticket_no,
            "sl": sl_,
            "tp": tp_,
        }
        result = mt5.order_send(request)
        return result

    def remove_tp_of_active_order(self, ticket_no, sl_):
        request = {
            "action": mt5.TRADE_ACTION_SLTP,
            "position": ticket_no,
            "sl": sl_,
        }
        result = mt5.order_send(request)
        return result

    def trial_stop_loss(self, sl_point):
        # for i in range(len(Terminal())):
        Terminal = MetaTraderHelper.get_active_orders_status()
        for i in range(len(Terminal)):
            position        = mt5.positions_get(ticket=int(Terminal['ticket'][i]))
            order_type      = Terminal['type'][i]
            price_current   = Terminal['price_current'][i]
            price_open      = Terminal()['price_open'][i]
            ticket          = int(Terminal['ticket'][i])
            symbol          = Terminal['symbol'][i]
            point           = mt5.symbol_info(Terminal['symbol'][i]).point
            new_sl = 0
            if order_type == mt5.ORDER_TYPE_BUY:
                if price_current > price_open:
                    if (price_current - price_open) > (sl_point * point):
                        new_sl = price_current - sl_point * point
                        print(f'symbol= {symbol}, new_sl= {new_sl}')
            elif order_type == mt5.ORDER_TYPE_SELL:
                if price_current < price_open:
                    if abs(price_current - price_open) > (sl_point * point):
                        new_sl = price_current + sl_point * point
                        print(f'symbol= {symbol}, new_sl= {new_sl}')
            else:
                pass

        request = {
            'action': mt5.TRADE_ACTION_SLTP,
            'position': position.ticket,
            'sl': new_sl
        }
        result = mt5.order_send(request)
        print(result)
        return result
#*_________________________________________________________________________________________________________________________________________________
class Placement_Order():
    def __init__(self, symbol, Lots_Size=0.01):

        # super().__init__(symbol, Lots_Size)
        self.symbol          = symbol
        try:
            self.point       = float(mt5.symbol_info(symbol).point)
        except Exception:
            self.point       = None    
    
        self.spread          = float(mt5.symbol_info(symbol).spread)
        self.Ask             = float(mt5.symbol_info_tick(symbol).ask)
        self.Bid             = float(mt5.symbol_info_tick(symbol).bid)

        self.TP              = 700
        self.SL              = 500

        self.Lots            = Lots_Size
        self.Additional_Lots = 0.01
        self.Stop_Gap_Factor = 4
        self.Lot_Factor_Stop = 2
        self.First_Order_TP_Point = 800*self.point
        self.First_Order_SL_Point = 800*self.point
        self.chk = self.Ask - self.First_Order_SL_Point
        self.BUY , self.SELL, self.BUYLIMIT , self.SELLLIMIT, self.BUYSTOP , self.SELLSTOP, =  'BUY', 'SELL', 'BUYLIMIT', 'SELLLIMIT', 'BUYSTOP', 'SELLSTOP' 
        # self.BUY , self.SELL, self.BUYLIMIT , self.SELLLIMIT, self.BUYSTOP , self.SELLSTOP, =  0, 1, 2, 3, 4, 5 

        self.data            = MetaTraderHelper.simple_csv_calling(stock_name=symbol)
        self.High_MA         = ta.trend.ema_indicator(self.data['high'], window=100, fillna=False).iloc[len(self.data['high'])-1]
        self.Low_MA          = ta.trend.ema_indicator(self.data['low'] , window=100, fillna=False).iloc[len(self.data['low'])-1]
        self.Stop_Gap_Factor = 4

        self.Stop_Point      = int((float(self.High_MA - self.Low_MA)*self.Stop_Gap_Factor)/self.point)
        self.Stop_1          = int(self.Stop_Point/3)
        self.Stop_2          = int(self.Stop_1*4/3)

        self.Close_Deal      = 1.40

        self.TP_1            = round(self.Stop_Point*self.Close_Deal)
        self.SL_1            = self.Stop_1+round(self.Stop_Point*(self.Close_Deal))-self.spread
        self.Dif_Buy         = Order_Details(Symbol).Dif_First_BUY_Price_Last_BUY_Price

        self.LotSize         = LotSizeCalculator.calculate_lot_size()
        self.Lot_Size_Buy    = Order_Details(self.symbol).Sum_Symbol_BUY_Vol
        self.Lot_Size_Sell   = Order_Details(self.symbol).Sum_Symbol_SELL_Vol

        self.Precent_of_STOP_after_22 = 0.5 
        self.Dimnish_Percentage = 0.1
        self.Dimnish_Percentage = 0.1

    def Order_001(self):
        '''This function is responsible for executing a market order of "BUY" with the help of uses the `OrderManager.market_order` function from the `fm5` module'''
        return OrderManager.market_order(symbol=self.symbol, volume=self.LotSize, order_type=self.BUY, 
                                      sl_=((self.Ask + (self.Stop_1*self.point)) - self.First_Order_SL_Point), 
                                      tp_=((self.Ask + (self.Stop_1*self.point)) + self.First_Order_TP_Point), 
                                      Pred_type='_001', Pending_Price= 0)

    def Order_002(self):
        '''This function is responsible for executing a market order of "SELL" with the help of uses the `OrderManager.market_order` function from the `fm5` module'''    
        return OrderManager.market_order(symbol=self.symbol, volume=self.LotSize, order_type=self.SELL, 
                                      sl_=((self.Bid + (self.Stop_1*self.point)) + self.First_Order_SL_Point), 
                                      tp_=((self.Bid - (self.Stop_1*self.point)) - self.First_Order_TP_Point), 
                                      Pred_type='_002', Pending_Price= 0)


    def Order_22201(self):
        '''This function is responsible for executing a market order of "BUYSTOP" with the help of uses the `OrderManager.market_order` function from the `fm5` module
        LotSize is Single - Stop Points are 1/3 of Difference of High_MA and Low_MA - SL 
        INDIVIDUAL ORDER '''    
        return OrderManager.market_order(symbol=self.symbol, volume=self.LotSize, order_type=self.BUYSTOP, 
                                      sl_=((self.Ask + (self.Stop_1*self.point)) - self.First_Order_SL_Point), 
                                      tp_=((self.Ask + (self.Stop_1*self.point)) + self.First_Order_TP_Point), 
                                      Pred_type='_22201', Pending_Price= (self.Ask+(self.Stop_1*self.point)) )

    def Order_22202(self):
        '''This function is responsible for executing a market order of "SELLSTOP" with the help of uses the `OrderManager.market_order` function from the `fm5` module
        LotSize is Single - Stop Points are 1/3 of Difference of High_MA and Low_MA - SL 
        INDIVIDUAL ORDER '''    
        return OrderManager.market_order(symbol=self.symbol, volume=self.LotSize, order_type=self.SELLSTOP, 
                                      sl_=((self.Bid - (self.Stop_1*self.point)) + self.First_Order_SL_Point), 
                                      tp_=((self.Bid - (self.Stop_1*self.point)) - self.First_Order_TP_Point), 
                                      Pred_type='_22202', Pending_Price= (self.Bid-(self.Stop_1*self.point)) )


    def Order_22203(self):
        '''This function is responsible for executing a market order of "BUYLIMIT" with the help of uses the `OrderManager.market_order` function from the `fm5` module
        price is Ask - Stop_1*point
        sl_ will be copy of 1st Order of sl of BUY - 
        tp_ will be the First BUY Price of Symbol - 
        LotSize will be DOUBLE '''
        return OrderManager.market_order(symbol=self.symbol, volume=self.Lot_Size_Buy*2,  order_type=self.BUYLIMIT,  
                                      sl_= Order_Details(self.symbol).First_Symbol_BUY_SL,  
                                      tp_= Order_Details(self.symbol).First_Symbol_BUY_Price,  
                                      Pred_type='_22203', Pending_Price= (self.Ask - (self.Stop_1*self.point)) )

    def Order_22204(self):
        '''This function is responsible for executing a market order of "SELLLIMIT" with the help of uses the `OrderManager.market_order` function from the `fm5` module
        price is Bid + Stop_1*point
        sl_ is copy of 1st Order of sl of SELL - 
        tp_ is copy of First Price SELL of Symbol - 
        LotSize will be DOUBLE '''
        return OrderManager.market_order(symbol=self.symbol, volume=self.Lot_Size_Sell*2, order_type=self.SELLLIMIT, 
                                      sl_=Order_Details(self.symbol).First_Symbol_SELL_SL, 
                                      tp_=Order_Details(self.symbol).First_Symbol_SELL_Price, 
                                      Pred_type='_22204', Pending_Price= (self.Bid + (self.Stop_1*self.point)) )


    def Order_22205(self):
        '''This function is responsible for executing a market order of "BUYSTOP" with the help of uses the `OrderManager.market_order` function from the `fm5` module
        price is Ask + Stop_2*point
        sl_ is copy of First_Symbol_SELL_TP - 
        tp_ is copy of First_Symbol_SELL_SL - 
        LotSize will be the Multipler '''
        self.price         = (self.Ask+(self.Stop_2*self.point))
        self.SLbuy         = Order_Details(self.symbol).First_Symbol_SELL_TP
        self.TPbuy         = Order_Details(self.symbol).First_Symbol_SELL_SL
        self.Lot_Open_Buy  = ((self.Lot_Size_Sell*self.Lot_Factor_Stop) - self.Lot_Size_Buy + self.Additional_Lots)
        return OrderManager.market_order(symbol=self.symbol, volume=self.Lot_Open_Buy, order_type=self.BUYSTOP, sl_= self.SLbuy, tp_= self.TPbuy, Pred_type='_22205', Pending_Price=self.price)

    def Order_22206(self):
        '''This function is responsible for executing a market order of "SELLSTOP" with the help of uses the `OrderManager.market_order` function from the `fm5` module
        price is Bid - Stop_2*point
        sl_ is copy of First_Symbol_BUY_TP - 
        tp_ is copy of First_Symbol_BUY_SL - 
        LotSize will be the Multipler '''
        self.price         = (self.Bid-(self.Stop_2*self.point))
        self.SLsell         = Order_Details(self.symbol).First_Symbol_BUY_TP
        self.TPsell         = Order_Details(self.symbol).First_Symbol_BUY_SL
        self.Lot_Open_Sell   = ((self.Lot_Size_Buy*self.Lot_Factor_Stop) - self.Lot_Size_Sell + self.Additional_Lots)
        return OrderManager.market_order(symbol=self.symbol, volume=self.Lot_Open_Sell, order_type=self.SELLSTOP, sl_=self.SLsell, tp_=self.TPsell, Pred_type='_22206', Pending_Price= self.price)

    #*______________________________________________________________________________________________ WORKING ORDERS OF THE ABOVE
    #*______________________________________________________________________________________________ WOKRING ON BELOW 

    def Order_22207(self):                                                              #? Have to Test this Order
        '''This Funcrion is continuation of a market order of "BUYSTOP" with the help of uses the `OrderManager.market_order` function from the `fm5` module
        price is Required_Symbol_BUY_Price of 2nd Order.
        sl_ is Required_Symbol_BUY_SL of 2nd Order-
        tp_ is Required_Symbol_BUY_TP of 2nd Order -
        LotSize will be the Multipler '''
        self.price         = Order_Details(self.symbol,1).Required_Symbol_BUY_Price
        self.SLbuy         = Order_Details(self.symbol,1).Required_Symbol_BUY_SL
        self.TPbuy         = Order_Details(self.symbol,1).Required_Symbol_BUY_TP
        self.Lot_Open_Buy  = ((self.Lot_Size_Sell*self.Lot_Factor_Stop) - self.Lot_Size_Buy + self.Additional_Lots)
        return OrderManager.market_order(symbol=self.symbol, volume=self.Lot_Open_BUY, order_type=self.BUYSTOP,   sl_=self.SLbuy, tp_=self.TPbuy,  Pred_type='_22207', Pending_Price= self.price )

    def Order_22208(self):                                                              #? Have to Test this Order
        '''This Funcrion is continuation of a market order of "SELLSTOP" with the help of uses the `OrderManager.market_order` function from the `fm5` module
        price is Required_Symbol_SELL_Price of 2nd Order.
        sl_ is Required_Symbol_SELL_SL of 2nd Order-
        tp_ is Required_Symbol_SELL_TP of 2nd Order -
        LotSize will be the Multipler '''
        self.price         = Order_Details(self.symbol,1).Required_Symbol_SELL_Price
        self.SLsell         = Order_Details(self.symbol,1).Required_Symbol_SELL_SL
        self.TPsell         = Order_Details(self.symbol,1).Required_Symbol_SELL_TP
        self.Lot_Open_Sell = ((self.Lot_Size_Buy*self.Lot_Factor_Stop) - self.Lot_Size_Sell + self.Additional_Lots)
        return OrderManager.market_order(symbol=self.symbol, volume=self.Lot_Open_SELL, order_type=self.SELLSTOP, sl_=self.SLsell, tp_=self.TPsell, Pred_type='_22208', Pending_Price= self.price )

    def Order_22209(self):
        '''This Funcrion is continuation of a market order of "BUYSTOP" with the help of uses the `OrderManager.market_order` function from the `fm5` module
        price is First_Symbol_SELL_Price .
        sl_ is   First_Symbol_SELL_TP-
        tp_ is   First_Symbol_BUY_Price-
        LotSize is Single as per Account Balance '''
        self.price = Order_Details(self.symbol).First_Symbol_SELL_Price
        self.SLbuy = Order_Details(self.symbol).First_Symbol_SELL_TP
        self.TPbuy = Order_Details(self.symbol).First_Symbol_BUY_Price
        return OrderManager.market_order(symbol=self.symbol, volume=self.LotSize, order_type=self.BUYSTOP, sl_=self.SLbuy, tp_=self.TPbuy, Pred_type='_009', Pending_Price= self.price )

    def Order_22210(self):
        '''This Funcrion is continuation of a market order of "BUYSTOP" with the help of uses the `OrderManager.market_order` function from the `fm5` module
        price is First_Symbol_BUY_Price .
        sl_ is   First_Symbol_BUY_TP-
        tp_ is   First_Symbol_SELL_Price-
        LotSize is Single as per Account Balance '''
        self.price  = Order_Details(self.symbol).First_Symbol_BUY_Price
        self.SLsell = Order_Details(self.symbol).First_Symbol_BUY_TP
        self.TPsell = Order_Details(self.symbol).First_Symbol_SELL_Price
        return OrderManager.market_order(symbol=self.symbol, volume=self.LotSize, order_type=self.SELLSTOP, sl_=self.SLsell,  tp_=self.TPsell, Pred_type='_010', Pending_Price= self.price )

    def Order_22211(self):
        self.price         = self.Bid   + (((Order_Details(self.symbol).First_Symbol_SELL_Price - Order_Details(self.symbol).Last_Symbol_SELLSTOP_Price)*self.Precent_of_STOP_after_22)/self.point)
        self.SLbuy         = self.Price - abs( (self.Price - Order_Details(self.symbol).First_Symbol_SELL_Price) )*self.Close_Deal  
        self.TPbuy         = self.Price - abs( (self.Price + Order_Details(self.symbol).First_Symbol_SELL_Price) )*self.Close_Deal  
        self.Lot_Open_Buy  = ((self.Lot_Size_Sell*self.Lot_Factor_Stop) - self.Lot_Size_Buy + self.Additional_Lots)
        return OrderManager.market_order(symbol=self.symbol, volume=self.Lot_Open_Buy, order_type=self.BUYSTOP,   sl_=self.SLbuy, tp_=self.TPbuy,  Pred_type='_011', Pending_Price= self.price )

    def Order_22212(self):
        self.price         = self.Ask   + (((Order_Details(self.symbol).First_Symbol_BUY_Price - Order_Details(self.symbol).Last_Symbol_BUYSTOP_Price)*self.Precent_of_STOP_after_22)/self.point)
        self.SLsell        = self.Price - abs( (self.Price + Order_Details(self.symbol).First_Symbol_BUY_Price) )*self.Close_Deal  
        self.TPsell        = self.Price - abs( (self.Price - Order_Details(self.symbol).First_Symbol_BUY_Price) )*self.Close_Deal  
        self.Lot_Open_Sell = ((self.Lot_Size_Buy*self.Lot_Factor_Stop) - self.Lot_Size_Sell + self.Additional_Lots)
        return OrderManager.market_order(symbol=self.symbol, volume=self.Lot_Open_Sell, order_type=self.SELLSTOP, sl_=self.SLsell, tp_=self.TPsell,  Pred_type='_012', Pending_Price= self.price )

    def Order_22213(self):
        self.price          =  Order_Details(self.symbol).First_Symbol_BUY_Price
        self.SLbuy          =  Order_Details(self.symbol).First_Symbol_BUY_SL
        self.TPbuy          =  Order_Details(self.symbol).First_Symbol_BUY_TP 
        self.Lot_Open_Buy   = ((self.Lot_Size_Sell*self.Lot_Factor_Stop) - self.Lot_Size_Buy + self.Additional_Lots)
        return OrderManager.market_order(symbol=self.symbol, volume=self.Lot_Open_Buy, order_type=self.BUYSTOP, sl_=self.SLbuy, tp_=self.TPbuy, Pred_type='_013', Pending_Price= self.price )

    def Order_22214(self):
        self.price          =   Order_Details(self.symbol).First_Symbol_BUY_Price
        self.SLsell         =   Order_Details(self.symbol).First_Symbol_SELL_SL
        self.TPsell         =   Order_Details(self.symbol).First_Symbol_SELL_TP
        self.Lot_Open_Sell  = ((self.Lot_Size_Buy*self.Lot_Factor_Stop) - self.Lot_Size_Sell + self.Additional_Lots)
        return OrderManager.market_order(symbol=self.symbol, volume=self.Lot_Open_Sell, order_type=self.SELLSTOP, sl_=self.SLsell, tp_=self.TPsell,   Pred_type='_014', Pending_Price= self.price )

    def Order_44453(self):
        self.price          = Order_Details(self.symbol).Last_Symbol_BUY_Price - (((Order_Details(self.symbol).First_Symbol_SELL_Price - Order_Details(self.symbol).Last_Symbol_BUY_Price)*self.Dimnish_Percentage)/self.point) 
        self.SLbuy          = self.price - abs( (self.Price - Order_Details(self.symbol).First_Symbol_SELL_Price) )*self.Close_Deal  
        self.TPbuy          = self.price - abs( (self.Price + Order_Details(self.symbol).First_Symbol_SELL_Price) )*self.Close_Deal
        self.Lot_Open_Buy   = ((self.Lot_Size_Sell*self.Lot_Factor_Stop) - self.Lot_Size_Buy + self.Additional_Lots)
        return OrderManager.market_order(symbol=self.symbol, volume=self.Lot_Open_Buy, order_type=self.BUYSTOP, sl_=self.SLbuy, tp_=self.TPbuy,  Pred_type='_053', Pending_Price= self.price )

    def Order_44454(self):
        self.price           = Order_Details(self.symbol).Last_Symbol_SELL_Price + (((Order_Details(self.symbol).First_Symbol_BUY_Price - Order_Details(self.symbol).Last_Symbol_SELL_Price)*self.Dimnish_Percentage)/self.point)
        self.SLsell          = self.price - abs( (self.price + Order_Details(self.symbol).First_Symbol_BUY_Price) )*self.Close_Deal  
        self.TPsell          = self.price - abs( (self.price - Order_Details(self.symbol).First_Symbol_BUY_Price) )*self.Close_Deal  
        self.Lot_Open_Sell  = ((self.Lot_Size_Buy*self.Lot_Factor_Stop) - self.Lot_Size_Sell + self.Additional_Lots)
        return OrderManager.market_order(symbol=self.symbol, volume=self.Lot_Open_Sell, order_type=self.SELLSTOP, sl_=self.SLsell, tp_=self.TPsell, Pred_type='_054', Pending_Price= self.price )

    def TP_Modify_Order(self, symbol, is_buy, is_lower, dif_gap):
        order_type = "BUY" if is_buy else "SELL"
        tp_price_func = Order_Details(symbol).First_Symbol_BUY_Price if is_buy else Order_Details(symbol).First_Symbol_SELL_Price

        if is_lower:
            order_list = Order_Details(symbol).get(f"Symbol_All_{order_type}")
            tp_modify_price = tp_price_func
        else:
            order_list = Order_Details(symbol).get(f"Symbol_All_{order_type}")
            tp_modify_price = tp_price_func + dif_gap

        for i in range(order_list['ticket'].count()):
            price = order_list.iloc[i]['price_open']
            sl = order_list.iloc[i]['sl']
            tp = order_list.iloc[i]['tp']
            ticket_no = order_list.iloc[i]['ticket']

            if (is_lower and tp < price) or (not is_lower and tp > price):
                return OrderManager.modify_active_order(ticket_no=ticket_no, sl_=sl, tp_=tp_modify_price)

        return None

    def SL_Modify_Order(self, symbol, is_buy, is_lower, sl_after_ask_bid_percent):
        order_type = "BUY" if is_buy else "SELL"
        sl_price_func = Order_Details(symbol).First_Symbol_SELL_Price if is_buy else Order_Details(symbol).First_Symbol_BUY_Price

        if is_lower:
            order_list = Order_Details(symbol).get(f"Symbol_All_{order_type}")
            sl_modify_price = sl_price_func + sl_after_ask_bid_percent * self.point
        else:
            order_list = Order_Details(symbol).get(f"Symbol_All_{order_type}")
            sl_modify_price = sl_price_func - sl_after_ask_bid_percent * self.point

        for i in range(order_list['ticket'].count()):
            price = order_list.iloc[i]['price_open']
            sl = order_list.iloc[i]['sl']
            tp = order_list.iloc[i]['tp']
            ticket_no = order_list.iloc[i]['ticket']

            if (is_lower and sl < price) or (not is_lower and sl > price):
                return OrderManager.modify_active_order(ticket_no=ticket_no, sl_=sl_modify_price, tp_=tp)
        return None
    

    def Pending_Order_Modify_Function(self, Order_Type, Price_Points, SL_Points, TP_Points):
        New_Price, New_SL, New_TP = [], [], []

        order_mapping = {
            "SELLLIMIT": "Symbol_All_SELLLIMIT",
            "BUYSTOP": "Symbol_All_BUYSTOP",
            "BUYLIMIT": "Symbol_All_BUYLIMIT",
            "SELLSTOP": "Symbol_All_SELLSTOP",
        }

        order_list_key = order_mapping.get(Order_Type)
        if not order_list_key:
            return

        OP = Order_Details(self.symbol).get(order_list_key)
        self.Price, self.sl, self.tp, self.ticket_no = Placement_Order.print_order_details(OP)

        if Order_Type == "SELLLIMIT" and self.Price - self.Bid > Price_Points * self.point and self.Price > self.Ask + Price_Points * self.point:
            New_Price = self.Bid + Price_Points * self.point
            if abs(New_Price - self.sl) / self.point != SL_Points:
                New_SL = New_Price + SL_Points * self.point
            if abs(New_Price - self.tp) / self.point != TP_Points:
                New_TP = New_Price - TP_Points * self.point
            return OrderManager.modify_pending_order(ticket_no=self.ticket_no, price=New_Price, sl=New_SL, tp=New_TP)

        if Order_Type == "BUYSTOP" and self.Price - self.Ask > Price_Points * self.point and self.Price > self.Ask + Price_Points * self.point:
            New_Price = self.Ask + Price_Points * self.point
            if abs(New_Price - self.sl) / self.point != SL_Points:
                New_SL = New_Price - SL_Points * self.point
            if abs(New_Price - self.tp) / self.point != TP_Points:
                New_TP = New_Price + TP_Points * self.point
            return OrderManager.modify_pending_order(ticket_no=self.ticket_no, price=New_Price, sl=New_SL, tp=New_TP)

        if Order_Type == "BUYLIMIT" and self.Price - self.Ask > Price_Points * self.point and self.Price < self.Ask - Price_Points * self.point:
            New_Price = self.Ask - Price_Points * self.point
            if abs(New_Price - self.sl) / self.point != SL_Points:
                New_SL = New_Price - SL_Points * self.point
            if abs(New_Price - self.tp) / self.point != TP_Points:
                New_TP = New_Price + TP_Points * self.point
            return OrderManager.modify_pending_order(ticket_no=self.ticket_no, price=New_Price, sl=New_SL, tp=New_TP)

        if Order_Type == "SELLSTOP" and self.Bid - self.Price > Price_Points * self.point and self.Price < self.Bid - Price_Points * self.point:
            New_Price = self.Bid - Price_Points * self.point
            if abs(New_Price - self.sl) / self.point != SL_Points:
                New_SL = New_Price + SL_Points * self.point
            if abs(New_Price - self.tp) / self.point != TP_Points:
                New_TP = New_Price - TP_Points * self.point
            return OrderManager.modify_pending_order(ticket_no=self.ticket_no, price=New_Price, sl=New_SL, tp=New_TP)



        # def TrialingPositionBuy(self,TrailingStopTL):
        #     pass

    def TrialingPositionBuy(self, trailingStop):                                    #^ Have to check this function
        Order_List = Order_Details(Symbol).Symbol_All_BUY
        for i in range(Order_List['ticket'].count()):
            self.Price      = float(Order_List.iloc[i]['price_open'])
            self.sl         = float(Order_List.iloc[i]['sl'])
            self.tp         = float(Order_List.iloc[i]['tp'])
            self.ticket_no  = int(Order_List.iloc[i]['ticket'])
            if self.Bid - self.Price > trailingStop * self.point:
                if self.sl < self.Bid - trailingStop * self.point:
                    OrderManager.modify_active_order(self.ticket_no, self.Bid - trailingStop * self.point)

    def TP_Removing_Order(self, Order_List):                                            #* Working Properly - 
        ''' 
        Order_List will be "Order_List= Order_Details(Symbol).Symbol_All_SELLLIMIT"
        Order_List will be "Order_List= Order_Details(Symbol).Symbol_All_Pending"
        '''
        for i in range(Order_List['ticket'].count()):
            Price      = float(Order_List.iloc[i]['price_open'])
            sl         = float(Order_List.iloc[i]['sl'])
            tp         = float(Order_List.iloc[i]['tp'])
            ticket_no  = int(Order_List.iloc[i]['ticket'])

            # return fm5.Remove_TP_of_Active_Order(ticket_no=ticket_no, sl_=sl)
            return OrderManager.remove_tp_of_active_order(ticket_no=ticket_no, sl_=sl)

    def TP_points_Modify_of_Active_Order(self, Order_Type, New_Tp):                    #* Working Properly - But you have to give the Points in integer.
        if Order_Type not in ["BUY", "SELL"]:
            return None

        order_list = Order_Details(Symbol).Symbol_All_BUY if Order_Type == "BUY" else Order_Details(Symbol).Symbol_All_SELL

        for i in range(order_list['ticket'].count()):
            price     = float(order_list.iloc[i]['price_open'])
            sl        = float(order_list.iloc[i]['sl'])
            tp        = float(order_list.iloc[i]['tp'])
            ticket_no = int(order_list.iloc[i]['ticket'])

            tp_points = abs(round(price / self.point - tp / self.point))
            new_tp = price + (New_Tp * self.point) if Order_Type == "BUY" else price - (New_Tp * self.point)
            # return fm5.Modify_Active_Order(ticket_no=ticket_no, sl_=sl,tp_=new_tp)
            return OrderManager.modify_active_order(ticket_no=ticket_no, sl_=sl,tp_=new_tp)

    def Delete_Stop_Function(self, Order_List):                                 #* It is working Properly.
        ''' 
        Order_List will be "Order_List= Order_Details(Symbol).Symbol_All_SELLLIMIT"
        Order_List will be "Order_List= Order_Details(Symbol).Symbol_All_Pending"
        '''
        self.result = False
        try:
            for _, order in Order_List.iterrows():
                self.ticket_no = order['ticket']
                # self.result = fm5.Remove_Order(self.ticket_no)
                self.result = OrderManager.remove_order(self.ticket_no)
        except:
            if not self.result:
                print("Some Error Arrived...")
            else:
                print("Error when order select = ")

    def Delete_Order_Function_By_Time_Type(self, Order_Type):
        order_mapping = {
            "SELLLIMIT" : "Symbol_All_SELLLIMIT",
            "BUYSTOP"   : "Symbol_All_BUYSTOP",
            "BUYLIMIT"  : "Symbol_All_BUYLIMIT",
            "SELLSTOP"  : "Symbol_All_SELLSTOP",
        }

        order_list_key = order_mapping.get(Order_Type)
        if not order_list_key:
            Order_List = Order_Details(self.symbol).get(order_list_key)
            current_time = TimeManager.get_current_time_number()

            for i in range(Order_List['ticket'].count()):
                price = float(Order_List.iloc[i]['price_open'])
                sl = float(Order_List.iloc[i]['sl'])
                tp = float(Order_List.iloc[i]['tp'])
                ticket_no = int(Order_List.iloc[i]['ticket'])
                time_setup = TimeManager.convert_datetime_to_number(Order_List.iloc[i]['time_setup'])

                if time_setup < current_time:
                    # return fm5.Remove_Order(ticket_no)
                    return OrderManager.remove_order(ticket_no)
        return None

    def auto_magic_number():
        # Define your logic to determine the auto magic number
        pass

    def modify_stop_loss(ticket, new_stop_loss):
        # Define your logic to modify the stop loss of the order with the given ticket
        pass

    def Pending_Trial_Order(self, Order_Type, Price_Points, SL_Points, TP_Points):
            order_mapping = {
                "SELLLIMIT": "Symbol_All_SELLLIMIT",
                "BUYSTOP": "Symbol_All_BUYSTOP",
                "BUYLIMIT": "Symbol_All_BUYLIMIT",
                "SELLSTOP": "Symbol_All_SELLSTOP",
                }

            if Order_Type not in order_mapping:
                return

            order_list_key = order_mapping[Order_Type]
            Order_List = Order_Details(Symbol).get(order_list_key)

            for i in range(Order_List['ticket'].count()):
                Price = float(Order_List.iloc[i]['price_open'])
                sl = float(Order_List.iloc[i]['sl'])
                tp = float(Order_List.iloc[i]['tp'])
                ticket_no = int(Order_List.iloc[i]['ticket'])

                if (
                    Order_Type in ["SELLLIMIT", "BUYSTOP"] and Price - self.Ask > Price_Points * self.point and Price > self.Ask + Price_Points * self.point
                ) or (
                    Order_Type in ["BUYLIMIT", "SELLSTOP"] and self.Bid - Price > Price_Points * self.point and Price < self.Ask - Price_Points * self.point
                ):
                    if Order_Type in ["SELLLIMIT", "BUYSTOP"]:
                        New_Price = self.Bid + Price_Points * self.point
                    else:
                        New_Price = self.Ask - Price_Points * self.point

                    if abs(New_Price - sl) / self.point != SL_Points:
                        New_SL = New_Price + SL_Points * self.point
                    if abs(New_Price - tp) / self.point != TP_Points:
                        New_TP = New_Price - TP_Points * self.point

                    print(f"{Order_Type} Modified at Price:", New_Price, "SL:", New_SL, "TP:", New_TP)
                    # return fm5.Modify_Pending_Order(ticket_no, New_Price, New_SL, New_TP)
                    return OrderManager.modify_pending_order(ticket_no, New_Price, New_SL, New_TP)

    def Close_All_Symbol_Orders(self):
            # Start a loop to scan all the orders.
            Order_List = Order_Details(self.symbol).Symbol_All_Active
            for i in range(Order_List['ticket'].count()):
                ticket_no = int(Order_List.iloc[i]['ticket'])
                
                # Close the order using your desired method (fm5.close_order in this case).
                print(f'Close the order Ticket no {ticket_no} of Symbol - {self.symbol}')
                # return fm5.close_order(ticket_no)
                return OrderManager.close_order(ticket_no)




        #? def Trialing_Buy_OrdersSL(self,  SL_CA_PCAB_BOM22_TSL ):
        #     pass
        #? def Trialing_Sell_OrdersSL( self, SL_CA_PCAB_BOM22_TSL ):
        #     pass

        #? def Delete_Pending_Order_Except_MACIGMA():
        #     pass

        #? def Delete_Order_Function_By_Type(self, OP_SELLSTOP):
        #     pass
        #? def Delete_Order_Function_By_Type(self, OP_BUYSTOP):
        #     pass
        #? def Delete_Order_Function_By_Type(self, OP_SELLSTOP):
        #     pass
        #? def Delete_Order_Function_By_Type(self, OP_BUYSTOP):
        #     pass
        #? def Close_All_Symbol_Orders(self):
        #     pass
        #? def Close_All_Orders_on_Req_Profit_of_Acc_Bal(self, Required_Total_Account_Profit_of_Percent_of_Acc_Bal):
        #     pass

    def SL_Changing_Greater_to_Lower_By_Type(self, Tral_Stop, Type):
        LP_Buy = Order_Details(self.symbol).Last_Symbol_BUY_Price
        LP_Sell = Order_Details(self.symbol).Last_Symbol_SELL_Price

        order_list = Order_Details(self.symbol).Symbol_All_Active
        Digits = 1 / self.point

        for i in range(order_list['ticket'].count()):
            price      = float(order_list.iloc[i]['price_open'])
            type       = str(order_list.iloc[i]['type'])
            sl         = float(order_list.iloc[i]['sl'])
            tp         = float(order_list.iloc[i]['tp'])
            ticket_no  = int(order_list.iloc[i]['ticket'])

            if type != Type:
                    continue

            while True:
                TS = Tral_Stop
                Points_Checking = abs(price - sl) / self.point
                if Points_Checking > Tral_Stop:
                    TS = Tral_Stop
                Modify = False
                if type == 'BUY':
                    if round(SL, Digits) < round(price - TS * self.point, Digits):
                        SL = LP_Buy + TS * self.point
                        Modify = True
                elif type == "SELL":
                    if round(SL, Digits) > round(price + TS * self.point, Digits) or round(SL, Digits) == 0:
                        SL = LP_Sell - TS * self.point
                        Modify = True

                if Modify == False:
                    break

                # Ans = fm5.Modify_Active_Order(ticket_no, price, SL, tp)
                Ans = OrderManager.modify_active_order(ticket_no, price, SL, tp)

                if Ans == True:
                    print(f"Order {ticket_no} is modified.")
                    break

    def TrialingPositionBuy22(self, trailingStop):
        Order_List = Order_Details(self.symbol).Symbol_All_BUY

        for i in range(Order_List['ticket'].count()):
            price = float(Order_List.iloc[i]['price_open'])
            sl = float(Order_List.iloc[i]['sl'])
            tp = float(Order_List.iloc[i]['tp'])
            ticket_no = int(Order_List.iloc[i]['ticket'])
            if self.Bid - price > trailingStop * self.point:
                if sl < self.Bid - trailingStop * self.point:
                    # ModifyStopLoss(Bid - trailingStop * self.point)
                    # fm5.Modify_Active_Order(ticket_no, price, (self.Bid - trailingStop * self.point), tp)
                    OrderManager.modify_active_order(ticket_no, price, (self.Bid - trailingStop * self.point), tp)

    def TrialingPositionSell22(self, trailingStop):
        Order_List = Order_Details(self.symbol).Symbol_All_BUY

        for i in range(Order_List['ticket'].count()):
            price = float(Order_List.iloc[i]['price_open'])
            sl = float(Order_List.iloc[i]['sl'])
            tp = float(Order_List.iloc[i]['tp'])
            ticket_no = int(Order_List.iloc[i]['ticket'])
            if price - self.Ask > trailingStop * self.point:
                if sl > self.Ask + trailingStop * self.point:
                    # ModifyStopLoss(self.Ask + trailingStop * self.point)
                    # fm5.Modify_Active_Order(ticket_no, price, (self.Ask + trailingStop * self.point), tp)
                    OrderManager.modify_active_order(ticket_no, price, (self.Ask + trailingStop * self.point), tp)
#*_________________________________________________________________________________________________________________________________________________
def Placing_Limit_Order(symbol, order_type):

    if order_type == "BUYLIMIT" and Order_Details(symbol).get(f"Count_Symbol_{order_type}") > 0 and Order_Details(symbol).get(f"Count_Symbol_{order_type}") < 2:
        Placement_Order.Order_22203()

    if order_type == "SELLLIMIT" and Order_Details(symbol).get(f"Count_Symbol_{order_type}") > 0 and Order_Details(symbol).get(f"Count_Symbol_{order_type}") < 2:
        Placement_Order.Order_22204()

def Algorithum_201(symbol):

    ask     = MetaTraderHelper().get_ask(symbol)
    bid     = MetaTraderHelper().get_bid(symbol)
    point   = MetaTraderHelper().get_point(symbol)
    Digits  = MetaTraderHelper().get_digits(symbol)

    Close_Deal         = 1.40
    LotSize = LotSizeCalculator(symbol).calculate_lot_size(1)

    Last_Order_Type = Order_Details(symbol).Last_Order_Type

    CAPO, CAO   =   Order_Details(symbol).Count_Symbol_All_Pending,  Order_Details(symbol).Count_Symbol_All_Active 
    
    CPO         =   Order_Details(symbol).Count_Symbol_BUYSTOP + Order_Details(symbol).Count_Symbol_SELLSTOP
    
    CPSB, CPSS  =   Order_Details(symbol).Count_Symbol_BUYSTOP,      Order_Details(symbol).Count_Symbol_SELLSTOP 
    CPLB, CPLS  =   Order_Details(symbol).Count_Symbol_BUYLIMIT,     Order_Details(symbol).Count_Symbol_SELLLIMIT
    CB, CS      =   Order_Details(symbol).Count_Symbol_BUY,          Order_Details(symbol).Count_Symbol_SELL
    BL, SL      =   Order_Details(symbol).Sum_Symbol_BUY_Vol,        Order_Details(symbol).Sum_Symbol_SELL_Vol     

    FBP, FSP    = Order_Details(symbol).First_Symbol_BUY_Price,    Order_Details(symbol).First_Symbol_SELL_Price
    FBSL, FSSL  = Order_Details(symbol).First_Symbol_BUY_SL,       Order_Details(symbol).First_Symbol_SELL_SL
    FBTP, FSTP  = Order_Details(symbol).First_Symbol_BUY_TP,       Order_Details(symbol).First_Symbol_SELL_TP

    FBSP, FSSP  = Order_Details(symbol).First_Symbol_BUYSTOP_Price , Order_Details(symbol).First_Symbol_SELLSTOP_Price
    FBSSL, FSSSL = Order_Details(symbol).First_Symbol_BUYSTOP_SL, Order_Details(symbol).First_Symbol_SELLSTOP_SL
    FBSTP, FSSTP = Order_Details(symbol).First_Symbol_BUYSTOP_TP, Order_Details(symbol).First_Symbol_SELLSTOP_TP

    LBP, LSP    = Order_Details(symbol).Last_Symbol_BUY_Price, Order_Details(symbol).Last_Symbol_SELL_Price
    LBSL, LSSL  = Order_Details(symbol).Last_Symbol_BUY_SL,    Order_Details(symbol).Last_Symbol_SELL_SL
    LBTP, LSTP  = Order_Details(symbol).Last_Symbol_BUY_TP,    Order_Details(symbol).Last_Symbol_SELL_TP 

    LBSP, LSSP   = Order_Details(symbol).Last_Symbol_BUYSTOP_Price, Order_Details(symbol).Last_Symbol_SELLSTOP_Price
    LBSSL, LSSSL = Order_Details(symbol).Last_Symbol_BUYSTOP_SL, Order_Details(symbol).Last_Symbol_SELLSTOP_SL
    LBSTP, LSSTP = Order_Details(symbol).Last_Symbol_BUYSTOP_TP, Order_Details(symbol).Last_Symbol_SELLSTOP_TP

    RBP2, RSP2   = Order_Details(symbol).Required_Symbol_BUY_Price, Order_Details(symbol).Required_Symbol_SELL_Price
    RBSL2, RSSL2 = Order_Details(symbol).Required_Symbol_BUY_SL, Order_Details(symbol).Required_Symbol_SELL_SL
    RBTP2, RSTP2 = Order_Details(symbol).Required_Symbol_BUY_TP, Order_Details(symbol).Required_Symbol_SELL_TP

    #?_______________________________________________________________________________________
    path                = 'D:\\Code - D\\Programming Codes\\Python_Learning\\My Stocks Working\\MT5_with_python\\'+'Stock_Data_'+dt.datetime.now().strftime('%Y-%m-%d')+'/'
    data                = DataFetcher(path).simple_csv_calling(symbol)
    High_MA, Low_MA     = ta.trend.ema_indicator(data['high'], window=1, fillna=False), ta.trend.ema_indicator(data['low'], window=1, fillna=False)
    Stop_Gap_Factor     = LotSizeCalculator(symbol).stop_gap()
    # Stop_Point          = round((High_MA - Low_MA)*Stop_Gap_Factor,point)
    Stop_Point          = round(((High_MA - Low_MA)/point)*Stop_Gap_Factor)
    #?_______________________________________________________________________________________
    Percent_SL_Change = 0.4

    Ask_to_Buy = ask > round(LBP + round(abs(LBP - LBTP) * Percent_SL_Change))
    SL_Greater_Buy = Order_Details(symbol).Last_Symbol_BUY_SL  > Order_Details(symbol).Last_Symbol_BUY_Price

    Bid_to_Sell = bid < round(LSP - round(abs(LSP - LSTP) * Percent_SL_Change))
    SL_Lesser_Sell = Order_Details(symbol).Last_Symbol_SELL_SL  < Order_Details(symbol).Last_Symbol_SELL_Price
    #?_______________________________________________________________________________________
    Dif_GAP = round(abs(FSP - FBP) * Close_Deal)
    Points_Required = 100
    #?_______________________________________________________________________________________

    # Previous Setting Amendment
    # MagicOrder = OrderMagicNumber() != Auto_Magic_Number() + 1
    One_Opened = CAO >= 1
    Two_Opened = CAO > 1
    # SameSymbol = OrderSymbol() == Symbol
    TS2 = CAO == 1 and CPO == 1
    TS3 = CAO == 1 and CPO == 0
    Buy_Order_MA1 = BL < SL
    Sell_Order_MA1 = BL > SL

    Start = CAO == 0 and CPO == 0
    DSF = CAO == 0 and CPO > 0
    DSF_Buy = CB == 0 and CPLB > 0
    DSF_Sell = CS == 0 and CPLS > 0
    # FTP = OrderSymbol() == Symbol() and CB > 0 and CS > 0
    # NewCandle = IsNewCandle()
    One_Buy = CB > 1
    One_Sell = CS > 1
    One_Buy_Limit = CPLB < 1
    One_Sell_Limit = CPLS < 1

    Stop_1              = round(Stop_Point / 3, 0)
    BuyLowerBoundaryG   = round(abs(FBP - RBP2) / point, 0) > 25
    BuyLowerBoundary    = round(abs(FBP - RBP2) / point, 0) < 25
    BuyUpperBoundaryG   = round(abs(FBP - RBP2) / point, 0) > 150
    BuyUpperBoundary    = round(abs(FBP - RBP2) / point, 0) < 150

    SellLowerBoundaryG  = round(abs(FSP - RSP2) / point, 0) > 25
    SellLowerBoundary   = round(abs(FSP - RSP2) / point, 0) < 25
    SellUpperBoundaryG  = round(abs(FSP - RSP2) / point, 0) > 150
    SellUpperBoundary   = round(abs(FSP - RSP2) / point, 0) < 150

    OrderManagement1 = CB > 0 and CS < 1
    OrderManagement2 = CB < 1 and CS > 0

    OrderManagement3 = CB > 1 and CS > 1
    OrderManagement4 = CB < 1 and CS < 1

    OrderManagement5 = CB > 0 and CS > 0
    OrderManagement6 = CB > 1 and CS > 1

    OrderManagement7 = CB > 1 and CS > 0
    OrderManagement8 = CB > 0 and CS > 1

    # Checking SL Level for both sides
    boundary = (abs(FBP - FBTP) / point or abs(FSP - FSTP) / point) < (abs(FBP - FSP) * Close_Deal) / point

    # 1st- Buy Position - Buy and BuyLimit difference
    close_point_b = int((abs(RBP2 - LSP) * Close_Deal) / point)
    buy_sl_boundary = abs(RBP2 - RBTP2) / point < close_point_b

    # 2nd- Sell Position - Sell and SellLimit difference
    close_point_s = int((abs(RSP2 - LBP) * Close_Deal) / point)
    sell_sl_boundary = abs(RSP2 - RSTP2) / point < close_point_s

    # 3rd- Buy Position & Sell Position Both side Difference
    close_point_n = int((abs(LBP - LSP) * Close_Deal) / point)
    netural_boundary_s = abs(LSP - LSTP) / point < close_point_n
    netural_boundary_b = abs(LBP - LBTP) / point < close_point_n

    fop_fot_lesser_buy_5 = abs(FBP - FBTP) / point < 5
    fop_fot_lesser_sell_5 = abs(FSP - FSTP) / point < 5

    First_Order_SL_Point, First_Order_TP_Point = 800, 800
    #?_______________________________________________________________________________________

    #^_______________________________________________________________________________________
    signal = []
    #^_______________________________________________________________________________________

    #!+------------------------------------------------------------------+------------------------------------------------------------------+
    #!| PLACING ORDERS                                                   |                                                                  |
    #!+------------------------------------------------------------------+------------------------------------------------------------------+
    if CPSB < 1 and signal == "Up":                                                                    #TODO --- Have to set the starting condition.
        Placement_Order(symbol).Order_22201()
        print("Start the EA with BUYSTOP - Level 1a")

    if CPSS < 1 and signal == "Down":                                        #^ Have to Place the Condition for 
        Placement_Order(symbol).Order_22202()
        print("Start the EA with SELLSTOP - Level 1b")
    #?_______________________________________________________________________________________
    #* LvL-04- Place Same LIMIT order - Order Conditions 1

    #* When there is 1 BUY order already opened
    if CB == 1 and CS < 1 and CPLB < 1 and FBSL < FBP and abs(FBP - FBTP) / point > 5 and Last_Order_Type == 'BUY':
        Placing_Limit_Order(symbol, "BUYLIMIT")
        # Placing_BUY_Limit(22203)
        print("Placing BUYLIMIT - LvL-4a")

    #* When there is 1 SELL order already opened
    if CB < 1 and CS == 1 and CPLS < 1 and FSSL > FSP and abs(FSP - FSTP) / point > 5 and Last_Order_Type == 'SELL':
        Placing_Limit_Order(symbol, "SELLLIMIT")
        # Placing_BUY_Limit(22204)
        print("Placing SELLLIMIT - LvL-4b")
    #?_______________________________________________________________________________________
    #* LvL-06- Place 1st Opposite SELLSTOP Order - Order Conditions 2

    #* When there are 2 BUY or 1 SELLSTOP orders already opened
    #* TP of BUYs' order is at FBP
    #* SL at their opened points
    if CB > 1 and CS < 1 and CPSB < 1 and CPSS < 1 and abs(FBP - FBTP) / point < 5 and Last_Order_Type == 'BUY':
        Placement_Order(symbol).Order_Entry(22206)
        print("Placing SELLSTOP of 1st - LvL-06a")

    if CB < 1 and CS > 1 and CPSB < 1 and CPSS < 1 and abs(FSP - FSTP) / point < 5 and Last_Order_Type == 'SELL':
        Placement_Order(symbol).Order_Entry(22205)
        print("Placing BUYSTOP of 1st - LvL-06b")
    #?_______________________________________________________________________________________
    #* 3a - When there is just one order at both sides

    #* By default, there must be more than 1 order at the trend side
    #* Placing Stop
    if CB <= 1 and CS <= 1 and CPSS < 1 and CPSB < 1 and Last_Order_Type == 'BUY' and FBTP > round(FBP + (10 / point)):
        Placement_Order(symbol).Order_Entry(22208)
        print("Placing SELLSTOP of 2nd and So on - Level 3c")

    if CB <= 1 and CS <= 1 and CPSS < 1 and CPSB < 1 and Last_Order_Type == 'SELL' and FSTP < round(FSP - (10 / point)):
        Placement_Order(symbol).Order_Entry(22207)
        print("Placing BUYSTOP of 2nd and So on - Level 3d")
    #?_______________________________________________________________________________________
    #* 5 - Place Recurring When there are both side orders opened with the difference of Required Point

    #* BUY Side
    if CB > 1 and CS > 0 and CPSB < 1 and round(abs(FBP - RBP2) / point) < round((Stop_Point / 3) + 25) and Last_Order_Type == 'SELL':
        Placement_Order(symbol).Order_Entry(22207)
        print("Placing BUYSTOP Recurring - Level 5a")

    if CB > 1 and CS > 0 and CPSS < 1 and round(abs(FBP - RBP2) / point) < round((Stop_Point / 3) + 25) and Last_Order_Type == 'BUY':
        Placement_Order(symbol).Order_Entry(22208)
        print("Placing SELLSTOP Recurring - Level 5b")

    #* SELL Side
    if CB > 0 and CS > 1 and CPSB < 1 and round(abs(FSP - RSP2) / point) < round((Stop_Point / 3) + 25) and Last_Order_Type == 'SELL':
        Placement_Order(symbol).Order_Entry(22207)
        print("Placing BUYSTOP Recurring - Level 5c")

    if CB > 0 and CS > 1 and CPSS < 1 and round(abs(FSP - RSP2) / point) < round((Stop_Point / 3) + 25) and Last_Order_Type == 'BUY':
        Placement_Order(symbol).Order_Entry(22208)
        print("Placing SELLSTOP Recurring - Level 5d")

    #* When there is just One Order Both Side
    #* Place STOP at First Price Level
    if CB == 1 and CS == 1 and CPSB < 1 and LSP == FSP and LBP == FBP and Order_Details(symbol).Sum_Symbol_BUY_Vol < Order_Details(symbol).Sum_Symbol_SELL_Vol:
        Placement_Order(symbol).Order_Entry(22213)
        print("Placing BUYSTOP Recurring - Level 5e")

    #* When there is just One Order Both Side
    #* Place STOP at First Price Level
    if CB == 1 and CS == 1 and CPSS < 1 and LSP == FSP and LBP == FBP and Order_Details(symbol).Sum_Symbol_BUY_Vol > Order_Details(symbol).Sum_Symbol_SELL_Vol:
        Placement_Order(symbol).Order_Entry(22214)
        print("Placing SELLSTOP Recurring - Level 5f")
    #?_______________________________________________________________________________________
    #* 6 - If Ask Price is Greater Than +60% of Open Price - Shift the SL at +10%
    #* Buy Side
    """
        for i in range(order_list['ticket'].count()):
            price       = order_list.iloc[i]['price_open']
            sl          = order_list.iloc[i]['sl']
            tp          = order_list.iloc[i]['tp']
            ticket_no   = order_list.iloc[i]['ticket']

    """
    #~ if CB > 0 and CS > 0 and CPSS < 2 and Ask_to_Buy == True and Bid_to_Sell == False and LSSP < round(LBP - (25 * point), Digits) and SLPoints != 100:
    if CB > 0 and CS > 0 and CPSS < 2 and Ask_to_Buy == True and Bid_to_Sell == False and LSSP < round(LBP - (25 * point), Digits) :
        if round(abs(FBP - FBTP) / point) > 5:
            # SL_Changing_Greater_to_Lower_By_Type(Points_Required, OP_BUY)
            Placement_Order(symbol).Order_22210()
            print("Shift the SL at +10% - BUY Side - Level 6a")

    #* Sell Side
    #~ if CB > 0 and CS > 0 and CPSB < 2 and Ask_to_Buy == False and Bid_to_Sell == True and LBSP > round(LSP + (25 * point), Digits) and SLPoints != 100:
    if CB > 0 and CS > 0 and CPSB < 2 and Ask_to_Buy == False and Bid_to_Sell == True and LBSP > round(LSP + (25 * point), Digits) :
        if round(abs(FSP - FSTP) / point) > 5:
            # SL_Changing_Greater_to_Lower_By_Type(Points_Required, OP_SELL)
            Placement_Order(symbol).Order_22209()
            print("Shift the SL at +10% - Sell Side - Level 6a")
    #?_______________________________________________________________________________________
    #* 10 - If there are zero BUY and Sell orders available >>> Then Place also BUYSTOP.
    #* Buy Side.
    if CB < 1 and CS > 0 and CPSB < 1 and CPSS > 0 and round(abs(LSP - LSSP) / point) > 125:
        Placement_Order(symbol).Order_Entry(22211)
        print("Zero BUY orders - Place also BUYSTOP - Level 10a")

    if CB < 1 and CS > 0 and CPSB > 0 and CPSS < 1 and round(abs(LBP - LBSP) / point) > 125:
        Placement_Order(symbol).Order_Entry(22212)
        print("Zero BUY orders - Place also BUYSTOP - Level 10b")

    #* Sell Side.
    if CB > 0 and CS < 1 and CPSB > 0 and CPSS < 1 and round(abs(LBP - LBSP) / point) > 125:
        Placement_Order(symbol).Order_Entry(22212)
        print("Zero SELL orders - Place also SELLSTOP - Level 10c")

    if CB > 0 and CS < 1 and CPSB < 1 and CPSS > 0 and round(abs(LSP - LSSP) / point) > 125:
        Placement_Order(symbol).Order_Entry(22211)
        print("Zero SELL orders - Place also SELLSTOP - Level 10d")
    #?_______________________________________________________________________________________
    #!+------------------------------------------------------------------+//+------------------------------------------------------------------+
    #!| Modify TP and SL Conditions                                      |  |                                                                  |
    #!+------------------------------------------------------------------+//+------------------------------------------------------------------+
    #* LvL-05- Change TP at First Buy Price.
    #* When There are 2 BUY Orders and Zero SELL order.
    #* TP of BUYs' order are at FBP
    #* SL at their opened points.
    if CB > 1 and CS < 1 and round(abs(FBP - FBTP) / point) > 5 and Last_Order_Type == 'BUY':
        Placement_Order(symbol).TP_Modify_Order(symbol=symbol, is_buy=True, is_lower=True, dif_gap=0)
        # TP_Modify_Buy_Lower(FBP)
        print("Modify the TP of BUY - Point 1 - LvL-05a")

    #* When There are 2 SELL Orders and Zero BUY order.
    #* TP of SELLs' order are at FSP
    #* SL at their opened points.
    if CB < 1 and CS > 1 and round(abs(FSP - FSTP) / point) > 5 and Last_Order_Type == 'SELL':
        Placement_Order(symbol).TP_Modify_Order(symbol=symbol, is_buy=False, is_lower=True, dif_gap=0)
        # TP_Modify_Sell_Lower(FSP)
        print("Modify the TP of SELL - Point 1 - LvL-05b")
    #?_______________________________________________________________________________________
    #* LvL-08- Change TP and SL with GAP of FBP and FSP * Close_Deal
    #* When there are both side order opened
    
    b_order_list = Order_Details(symbol).Count_Symbol_BUY
    s_order_list = Order_Details(symbol).Count_Symbol_SELL

    try:
        for order_list in [b_order_list, s_order_list]:
            for i in range(len(order_list['ticket'])):
                try:
                    bprice      = float(b_order_list.iloc[i]['price_open'])
                    bsl         = float(b_order_list.iloc[i]['sl'])
                    btp         = float(b_order_list.iloc[i]['tp'])
                    bticket_no  = int(b_order_list.iloc[i]['ticket'])
                    sprice      = float(s_order_list.iloc[i]['price_open'])
                    ssl         = float(s_order_list.iloc[i]['sl'])
                    stp         = float(s_order_list.iloc[i]['tp'])
                    sticket_no  = int(s_order_list.iloc[i]['ticket'])
                    
                    #* Continue with the rest of your code for each iteration
                    
                except (KeyError, IndexError, ValueError) as e:
                    # Handle specific exceptions that may occur
                    print(f"Error: {e}")
                    continue
                
    except Exception as e:
        # Handle any other unexpected exceptions
        print(f"Error: {e}")

    if CB > 0 and CS > 0 and not Ask_to_Buy and not Bid_to_Sell:
        buy_tp  = round(FBP + Dif_GAP, Digits)
        sell_tp = round(FSP - Dif_GAP, Digits)
        buy_sl  = round(FSP - Dif_GAP, Digits)
        sell_sl = round(FBP + Dif_GAP, Digits)

        if (bprice + abs(btp - bprice)) != buy_tp:
            Placement_Order(symbol).TP_points_Modify_of_Active_Order("BUY", buy_tp)
            print("Modified TP at BUY Side - LvL-08b")

        if (sprice - abs(stp - sprice)) != sell_tp:
            Placement_Order(symbol).TP_points_Modify_of_Active_Order("SELL", sell_tp)
            print("Modified TP at SELL Side - LvL-08d")

        if (sprice - abs(ssl - sprice)) != buy_sl:
            Placement_Order(symbol).TP_points_Modify_of_Active_Order("BUY", buy_sl)
            print("Modified SL at BUY Side - LvL-08a")

        if (bprice + abs(bsl - bprice)) != sell_sl:
            Placement_Order(symbol).TP_points_Modify_of_Active_Order("SELL", sell_sl)
            print("Modified SL at SELL Side - LvL-08c")

    #*----------------------------------------------- The Contra of LvL-05
    #?_______________________________________________________________________________________
    #*-- LvL-9-  Change TP >>> When there are more then 1 order of same side.

    #*----------------------------------------------- The Same of LvL 5
    #?_______________________________________________________________________________________
    #* LvL-10- Change SL
    #* When Ask is Greater than 40% of FBP
    if (CB > 0 and CS > 0 and CPSS < 2 and FBP > FBSL and Ask_to_Buy and not Bid_to_Sell):
        # SL_Changing_Greater_to_Lower_By_Type(Points_Required, "BUY")
        Placement_Order(symbol).SL_Changing_Greater_to_Lower_By_Type(Points_Required, "BUY")
        print("Shift the SL at +10% - BUY Side - LvL-10a")

    #* When Bid is Lesser than 40% of FSP
    if (CB > 0 and CS > 0 and CPSB < 2 and FSP < FSSL and not Ask_to_Buy and Bid_to_Sell):
        # SL_Changing_Greater_to_Lower_By_Type(Points_Required, "SELL")
        Placement_Order(symbol).SL_Changing_Greater_to_Lower_By_Type(Points_Required, "SELL")
        print("Shift the SL at -10% - SELL Side - LvL-10b")

    #*----------------------------------------------- Linked with LvL-10 - LvL-11 - LvL-12
    #!+------------------------------------------------------------------+//+------------------------------------------------------------------+
    #!| Trailing Conditions                                              |  |                                                                  |
    #!+------------------------------------------------------------------+//+------------------------------------------------------------------+

    #?_______________________________________________________________________________________
    #* LvL-02- Trial the Order => When There is just one STOP order
    if (CAO > 0 and CAPO <= 1):
        # f2fm5.Trial_StopLoss(sl_Point=200)
        OrderManager.trial_stop_loss(sl_Point=200)
        # TrialingStopFunction()
        print("Start Trialing the First Order - LvL-02")

    #?_______________________________________________________________________________________
    #* LvL-03- Trailing STOPLOSS of 1st Order
    #* When There is Just [1 Active Order] & [1 LIMIT Order BASED on 4th Level] on the Field
    if (CAO < 1 and CAPO == 1):
        Placement_Order(symbol).Pending_Order_Modify_Function(Order_List=Order_Details(Symbol).Symbol_All_BUYSTOP, Price_Points=200, SL_Points=500, TP_Points=500)
        Placement_Order(symbol).Pending_Order_Modify_Function(Order_List=Order_Details(Symbol).Symbol_All_SELLSTOP, Price_Points=200, SL_Points=500, TP_Points=500)
        # Pending_Order_Modify_Function(200, 500, 500)
        print("Trailing the STOP - LvL-03")
    #?_______________________________________________________________________________________
    #* LvL-15- Trial the SL of 11th & Price of 12th
    #* When TOP SELL opened and TOP Buy not
    #* When BUYSTOP opened .
    #* Just SELL orders on the field.
    #* Just 1 order of SELLSTOP.
    #* TP will be automatically changed at FSP because there is ZERO BUY Order according to LvL-05

    if (CB < 1 and CS > 1 and CPSB == 1 and CPSS < 1 and Order_Details(symbol).Last_Symbol_SELL_Vol == LotSize and abs(FSP - LSP) / point > 125):
        Placement_Order(symbol).TrialingPositionSell22(75)
        print("Trailing of SELL-22 order- Level 15a")

    if (CB > 1 and CS < 1 and CPSB < 1 and CPSS == 1 and Order_Details(symbol).Last_Symbol_BUY_Vol == LotSize and abs(FBP - LBP) / point > 125):
        Placement_Order(symbol).TrialingPositionSell22(75)
        print("Trailing of BUY-22 order- Level 15b")
    #?_______________________________________________________________________________________
    #* LvL-16- Trial the Pending order Price of LvL-13
    #* When TOP SELL opened and TOP Buy not
    #* When BUYSTOP not Opened .
    #* Just SELL orders on the field.
    #* Just 1 order of BUYSTOP.
    #* TP will be automatically changed at FSP because there is ZERO BUY Order according to LvL-05

    if (CB < 1 and CS > 1 and CPSB == 1 and CPSS < 1 and Order_Details(symbol).Last_Symbol_SELL_Vol == LotSize and abs(FSP - LSP) / point > 125 and Last_Order_Type == 'SELL'):
        Placement_Order(symbol).Pending_Order_Modify_Function(Order_List=Order_Details(Symbol).Symbol_All_BUYSTOP, Price_Points=200, SL_Points=200, TP_Points=200)
        # Pending_Trial_Order(OP_BUYSTOP, 175, 100, 100)
        print("Trailing of SELLSTOP-22- LvL-16a")

    if (CB > 1 and CS < 1 and CPSB < 1 and CPSS == 1 and Order_Details(symbol).Last_Symbol_BUY_Vol == LotSize and abs(FBP - LBP) / point > 125 and Last_Order_Type == 'BUY'):
        Placement_Order(symbol).Pending_Order_Modify_Function(Order_List=Order_Details(Symbol).Symbol_All_SELLSTOP, Price_Points=200, SL_Points=200, TP_Points=200)
        # Pending_Trial_Order(OP_SELLSTOP, 175, 100, 100)
        print("Trailing of SELLSTOP-22- LvL 16b")
    #?_______________________________________________________________________________________
    #!+------------------------------------------------------------------+//+------------------------------------------------------------------+
    #!| Delete Orders Conditions                                         |  |                                                                  |
    #!+------------------------------------------------------------------+//+------------------------------------------------------------------+
    
    #?_______________________________________________________________________________________
    #* LvL-12- Delete the Previous SELLSTOP when there is SELLSTOP at top
    if (CB > 0 and CS > 0 and CPSS > 1 and FSSP < LSSP and FSSP < round(abs(FSP + 125 * point), Digits) and FBP < FBSL):
        #& Need Delete Order by time Calculator
        Placement_Order(symbol).Delete_Stop_Function(Order_List=Order_Details(Symbol).Symbol_All_SELLSTOP)
        # Delete_Order_Function_By_Time_Type(OP_SELLSTOP)
        Placement_Order.Delete_Order_Function_By_Time_Type(Order_Type='SELLSTOP')
        print("Delete SELLSTOP when SELLSTOP Order at TOP at BUY Price - LvL 12a")

    if (CB > 0 and CS > 0 and CPSB > 1 and FBSP > LBSP and FBSP > round(abs(FBP - 125 * point), Digits) and FSP > FSSL):
        #& Need Delete Order by time Calculator
        Placement_Order(symbol).Delete_Stop_Function(Order_List=Order_Details(Symbol).Symbol_All_BUYSTOP)
        # Delete_Order_Function_By_Time_Type(OP_BUYSTOP)
        Placement_Order.Delete_Order_Function_By_Time_Type(Order_Type='BUYSTOP')
        print("Delete BUYSTOP when BUYSTOP Order at BOTTOM at SELL Price - LvL 12b")

    #*----------------------------------------------- Linked with LvL-10 - LvL-11 - LvL-12
    #?_______________________________________________________________________________________
    #* LvL-14- Delete Level 11th's SELLSTOP when Level 12th's BUYSTOP opened.
    #* When BUYSTOP opened.
    #* Just SELL orders on the field.
    #* Just 1 order of SELLSTOP.
    #* TP will be automatically changed at FSP because there is ZERO BUY Order according to LvL-05
    if (CB > 0 and CS > 0 and CPSS > 0 and Order_Details(symbol).Last_Symbol_SELLSTOP_Vol == LotSize and LSSP > round(FSP + (125 * point), Digits) and FBP > FBSL):
        Placement_Order(Symbol).Delete_Stop_Function(Order_List=Order_Details(Symbol).Symbol_All_SELLSTOP)
        print("Delete SELLSTOP order when BUYSTOP Opened - LvL 14a")

    if (CB > 0 and CS > 0 and CPSB > 0 and Order_Details(symbol).Last_Symbol_BUYSTOP_Vol == LotSize and LBSP < round(FBP - (125 * point), Digits) and FSP < FSSL):
        Placement_Order(Symbol).Delete_Stop_Function(Order_List=Order_Details(Symbol).Symbol_All_BUYSTOP)
        print("Delete BUYSTOP order when SELLSTOP Opened - LvL 14b")
    #?_______________________________________________________________________________________
    #* When BUY opened TP and SL already changed due to LvL-08
    #* LvL-16- Delete Pending order when there is zero active order
    #* LotSize is greater than LotSize
    Lot_Checking = (Order_Details(symbol).Sum_Symbol_BUYSTOP_Vol or Order_Details(symbol).Sum_Symbol_SELLSTOP_Vol or Order_Details(symbol).Sum_Symbol_BUYLIMIT_Vol or Order_Details(symbol).Sum_Symbol_SELLLIMIT_Vol == LotSize)

    if (CB < 1 and CS < 1 and Lot_Checking == False and (CPSB or CPSS or CPLB or CPLS) == 1 and CAPO > 0 ):
    #~ if (CB < 1 and CS < 1 and Lot_Checking == False and (CPSB or CPSS or CPLB or CPLS) == 1 and CAPO > 0 and MagicOrder == True):
        #& Last Pending Order - Have to Make calculation of last Pending if any for deleting
        Placement_Order(Symbol).Delete_Stop_Function(Order_List=Order_Details(Symbol).Symbol_All_Pending)
        print("Delete last pending order - Level LvL-16")
    #?_______________________________________________________________________________________
#*_________________________________________________________________________________________________________________________________________________

class entry_point_202:
    def __init__(self, symbol, path, folder):
        self.symbol = symbol
        self.path = path
        self.folder = folder
        self.save_folder = 'Entry_Folder\\'

    def _data_fetching(self):
        self.dataframe = pd.read_csv(self.path + self.folder + self.symbol + '.csv')
        self.dataframe = MultiplesStrategiesSignal(self.dataframe).generate_strategy_signals()
        # self.dataframe.drop(['time', 'open', 'high', 'low', 'close', 'tick_volume'], axis=1, inplace=True)
        return self.dataframe

    def entry_on_count_signal(self):
        self.dataframe = self._data_fetching()
        # Select specific columns
        selected_columns = ['ATR_Signal', 'EMA50_100_Signal', 'MA30_100_Signal', 'RSI_Signal', 'EMA_RSI_ATR_Signal', 'MACD_RSI_Signal', 'MACD_RSI_BB_Signal', 'ADX_VWAP_MA50_Signal', 
                            'Gann_Signal', 'MACD_signal', 'MACD_histogram_signal', 'BB_Signal', 'Stochastic_Signal', 'Fibonacci_Signal', 'Ichimoku_Signal', 'Parabolic_SAR_Signal',
                            'OBV_Signal', 'ADX_Signal', 'CCI_Signal', 'Williams_R_Signal', 'Donchian_Signal', 'Elliott_Wave_Signal', 'Price_Action_Signal']

        self.dataframe['T_Count'] = self.dataframe[selected_columns].sum(axis=1)
        self.dataframe['Count_1'] = self.dataframe[selected_columns].eq(1).sum(axis=1)
        self.dataframe['Count_0'] = self.dataframe[selected_columns].eq(0).sum(axis=1)
        self.dataframe['Count_-1'] = self.dataframe[selected_columns].eq(-1).sum(axis=1)

        self.dataframe['Entry_30%'] = np.where(self.dataframe['Count_1'] > self.dataframe['T_Count'] * 0.3, 1, np.where(self.dataframe['Count_-1'] > self.dataframe['T_Count'] * 0.3, -1, 0))
        self.dataframe['Entry_40%'] = np.where(self.dataframe['Count_1'] > self.dataframe['T_Count'] * 0.4, 1, np.where(self.dataframe['Count_-1'] > self.dataframe['T_Count'] * 0.4, -1, 0))
        self.dataframe['Entry_50%'] = np.where(self.dataframe['Count_1'] > self.dataframe['T_Count'] * 0.5, 1, np.where(self.dataframe['Count_-1'] > self.dataframe['T_Count'] * 0.5, -1, 0))
        self.dataframe['Entry_60%'] = np.where(self.dataframe['Count_1'] > self.dataframe['T_Count'] * 0.6, 1, np.where(self.dataframe['Count_-1'] > self.dataframe['T_Count'] * 0.6, -1, 0))
        print(self.dataframe)
        self.dataframe.to_csv(self.path + self.save_folder + self.symbol + '.csv', index=False)
        return self.dataframe

    def entry_on_add_signal(self):
        self.dataframe                      = self.entry_on_count_signal()
        self.dataframe['Add_Signal']        = self.dataframe['Count_1'] - self.dataframe['Count_-1']
        self.dataframe['Entry_Add_Signal']  = np.where(self.dataframe['Add_Signal'] > ((self.dataframe['T_Count'] * 0.5) * 0.4), 1, np.where(self.dataframe['Add_Signal'] < ((self.dataframe['T_Count'] * 0.5) * 0.4), -1, 0))
        print(self.dataframe)
        self.dataframe.to_csv(self.path + self.save_folder + self.symbol + '.csv', index=False)
        return self.dataframe

